name: Android CI/CD

on:
  workflow_dispatch:
  push:
    branches: [main]
  pull_request:

concurrency:
  group: android-ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-test:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    outputs:
      firebase_configured: ${{ steps.validate_required_secrets.outputs.firebase_configured }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - api: 32
            avd: pixel7pro_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 8192
            disk_mb: 12288
            device_id: pixel_7_pro
            device_label: pixel-7-pro
            skin: 1440x3120
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel 7 Pro
              hw.lcd.width=1440
              hw.lcd.height=3120
              hw.lcd.density=512
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3120
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: galaxys24ultra_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 12288
            disk_mb: 12288
            device_id: pixel_7_pro
            device_label: galaxy-s24-ultra
            skin: 1440x3120
            hardware_overrides: |
              hw.device.manufacturer=Samsung
              hw.device.name=Galaxy S24 Ultra
              hw.lcd.width=1440
              hw.lcd.height=3120
              hw.lcd.density=500
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3120
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: galaxys23ultra_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 10240
            disk_mb: 12288
            device_id: pixel_7
            device_label: galaxy-s23-ultra
            skin: 1440x3088
            hardware_overrides: |
              hw.device.manufacturer=Samsung
              hw.device.name=Galaxy S23 Ultra
              hw.lcd.width=1440
              hw.lcd.height=3088
              hw.lcd.density=500
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3088
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: pixelfold_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 8192
            disk_mb: 12288
            device_id: pixel_fold
            device_label: pixel-fold
            skin: 2208x1840
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel Fold
              hw.lcd.width=2208
              hw.lcd.height=1840
              hw.lcd.density=380
              hw.displayRegion.0.width=1840
              hw.displayRegion.0.height=2208
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: pixeltablet_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 12288
            disk_mb: 12288
            device_id: pixel_tablet
            device_label: pixel-tablet
            skin: 2560x1600
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel Tablet
              hw.lcd.width=2560
              hw.lcd.height=1600
              hw.lcd.density=280
              hw.displayRegion.0.width=2560
              hw.displayRegion.0.height=1600
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
    env:
      GRADLE_OPTS: "-Dorg.gradle.jvmargs=-Xmx4g"
      ARTIFACTS_DIR: artifacts
      KEYSTORE_PATH: ${{ github.workspace }}/android-release.jks
      SIGNING_KEY_ALIAS: ${{ secrets.ANDROID_SIGNING_KEY_ALIAS }}
      SIGNING_KEY_PASSWORD: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}
      SIGNING_STORE_PASSWORD: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
      NOVAPDF_APP_ID: ${{ vars.NOVAPDF_APP_ID || secrets.NOVAPDF_APP_ID || 'com.novapdf.reader' }}
      APP_PACKAGE_NAME: ${{ vars.NOVAPDF_APP_ID || secrets.NOVAPDF_APP_ID || 'com.novapdf.reader' }}
    steps:
      - name: Validate required secrets
        id: validate_required_secrets
        env:
          AWS_ACCESS_KEY_ID_SECRET: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY_SECRET: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME_SECRET: ${{ secrets.S3_BUCKET_NAME }}
          STRESS_PDF_KEY: ${{ vars.STRESS_PDF_S3_KEY || secrets.STRESS_PDF_S3_KEY }}
          THOUSAND_PDF_KEY: ${{ vars.THOUSAND_PAGE_PDF_S3_KEY || secrets.THOUSAND_PAGE_PDF_S3_KEY }}
          ANDROID_KEYSTORE_BASE64_SECRET: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_SIGNING_STORE_PASSWORD_SECRET: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
          ANDROID_SIGNING_KEY_ALIAS_SECRET: ${{ secrets.ANDROID_SIGNING_KEY_ALIAS }}
          ANDROID_SIGNING_KEY_PASSWORD_SECRET: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}
          FIREBASE_SERVICE_ACCOUNT_JSON_SECRET: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
          FIREBASE_PROJECT_ID_VALUE: ${{ vars.FIREBASE_PROJECT_ID || secrets.FIREBASE_PROJECT_ID }}
        run: |
          set -e
          missing=false
          firebase_missing=false

          if [ -z "${AWS_ACCESS_KEY_ID_SECRET:-}" ]; then
            echo "::error::Missing AWS_ACCESS_KEY_ID secret required for S3 uploads."
            echo "Remediation: Create an access key in AWS IAM (Users → Your deployment user → Security credentials → Create access key) with permissions for the target bucket, then add the value as the AWS_ACCESS_KEY_ID repository secret."
            missing=true
          fi

          if [ -z "${AWS_SECRET_ACCESS_KEY_SECRET:-}" ]; then
            echo "::error::Missing AWS_SECRET_ACCESS_KEY secret required for S3 uploads."
            echo "Remediation: Copy the secret key generated alongside the IAM access key above and store it as the AWS_SECRET_ACCESS_KEY repository secret. Regenerate the key if it is no longer visible."
            missing=true
          fi

          if [ -z "${S3_BUCKET_NAME_SECRET:-}" ]; then
            echo "::error::Missing S3_BUCKET_NAME secret required for S3 uploads."
            echo "Remediation: Provision an S3 bucket (e.g., nova-pdf-artifacts) in the AWS console, ensure the IAM user has s3:PutObject/s3:ListBucket permissions, then add the bucket name as the S3_BUCKET_NAME repository secret."
            missing=true
          fi

          if [ -z "${STRESS_PDF_KEY:-}" ]; then
            echo "::error::Missing STRESS_PDF_S3_KEY repository variable or secret required to download the stress PDF fixture."
            echo "Remediation: Record the S3 object key for the stress PDF (for example, fixtures/stress-large.pdf) and add it as the STRESS_PDF_S3_KEY repository variable or secret."
            missing=true
          fi

          if [ -z "${THOUSAND_PDF_KEY:-}" ]; then
            echo "::error::Missing THOUSAND_PAGE_PDF_S3_KEY repository variable or secret required to download the thousand-page PDF fixture."
            echo "Remediation: Record the S3 object key for the thousand-page PDF (for example, fixtures/stress-thousand-pages.pdf) and add it as the THOUSAND_PAGE_PDF_S3_KEY repository variable or secret."
            missing=true
          fi

          if [ -z "${ANDROID_KEYSTORE_BASE64_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_KEYSTORE_BASE64 secret required to sign the release bundle."
            echo "Remediation: Generate a release keystore (keytool -genkeypair -v -keystore nova-release.jks -alias nova -keyalg RSA -keysize 4096 -validity 10000), base64 encode it (base64 nova-release.jks), and save the output as the ANDROID_KEYSTORE_BASE64 repository secret."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_STORE_PASSWORD_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_STORE_PASSWORD secret required to unlock the keystore."
            echo "Remediation: Store the keystore password selected during key creation as the ANDROID_SIGNING_STORE_PASSWORD repository secret."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_KEY_ALIAS_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_KEY_ALIAS secret required for signing."
            echo "Remediation: Record the alias supplied when running keytool (e.g., nova) and add it as the ANDROID_SIGNING_KEY_ALIAS repository secret so Gradle knows which key to use."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_KEY_PASSWORD_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_KEY_PASSWORD secret required to access the signing key."
            echo "Remediation: Store the key password (often the same as the store password unless you set a separate value) as the ANDROID_SIGNING_KEY_PASSWORD repository secret."
            missing=true
          fi

          if [ -z "${FIREBASE_SERVICE_ACCOUNT_JSON_SECRET:-}" ]; then
            echo "::warning::Missing FIREBASE_SERVICE_ACCOUNT_JSON secret required for Firebase Test Lab instrumentation coverage."
            echo "Remediation: Create a Google Cloud service account with the Firebase Test Lab Admin and Storage Object Admin roles, generate a JSON key, and save the key contents as the FIREBASE_SERVICE_ACCOUNT_JSON repository secret."
            firebase_missing=true
          fi

          if [ -z "${FIREBASE_PROJECT_ID_VALUE:-}" ]; then
            echo "::warning::Missing FIREBASE_PROJECT_ID repository variable or secret required to target the Firebase project for physical device testing."
            echo "Remediation: Note the Google Cloud project ID that hosts Firebase Test Lab (e.g., nova-pdf-prod) and store it either as the FIREBASE_PROJECT_ID repository variable or secret."
            firebase_missing=true
          fi

          if [ "$firebase_missing" = true ]; then
            echo "::notice::Firebase secrets missing; Firebase Test Lab jobs will be skipped."
            echo "firebase_configured=false" >> "$GITHUB_OUTPUT"
          else
            echo "firebase_configured=true" >> "$GITHUB_OUTPUT"
          fi

          if [ "$missing" = true ]; then
            exit 1
          fi
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            gradle-
      - name: Grant execute permission for Gradle
        run: chmod +x gradlew
      - name: Decode signing keystore
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
        run: |
          set -euo pipefail
          echo "Decoding Android signing keystore to $KEYSTORE_PATH"
          python3 -c "import base64, os; encoded = os.environ['ANDROID_KEYSTORE_BASE64'].strip().encode(); path = os.environ['KEYSTORE_PATH']; open(path, 'wb').write(base64.b64decode(encoded))"
          chmod 600 "$KEYSTORE_PATH"
      - name: Download Android SDK components
        env:
          API_LEVEL: ${{ matrix.api }}
          ABI: ${{ matrix.abi }}
          TAG: ${{ matrix.tag }}
        run: |
          yes | $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager --licenses
          $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager "platform-tools" "platforms;android-${API_LEVEL}" "system-images;android-${API_LEVEL};${TAG};${ABI}" "build-tools;34.0.0" "emulator"
      - name: Add Android platform tools to PATH
        run: echo "$ANDROID_HOME/platform-tools" >> "$GITHUB_PATH"
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - name: Validate AWS credential scope
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
        run: |
          set -euo pipefail
          aws sts get-caller-identity --query 'Account' --output text >/dev/null
          aws iam get-user --query 'User.Arn' --output text >/dev/null 2>/dev/null || true
      - name: Run unit tests
        run: ./gradlew testDebugUnitTest --info
      - name: Start emulator
        env:
          API_LEVEL: ${{ matrix.api }}
          ABI: ${{ matrix.abi }}
          RUNNER_OS: ${{ runner.os }}
        run: |
          set -euo pipefail

          if [ -n "${ANDROID_AVD_HOME:-}" ]; then
            avd_root="${ANDROID_AVD_HOME%/}"
          elif [ -n "${ANDROID_SDK_HOME:-}" ]; then
            avd_root="${ANDROID_SDK_HOME%/}/avd"
          else
            avd_root="${HOME%/}/.android/avd"
          fi

          mkdir -p "$avd_root"
          export ANDROID_AVD_HOME="$avd_root"
          explicit_avd_dir="${avd_root}/${{ matrix.avd }}.avd"

          create_cmd=("$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager" create avd -n ${{ matrix.avd }} -k "system-images;android-${API_LEVEL};${{ matrix.tag }};${ABI}" --force --path "${explicit_avd_dir}")
          if [ -n "${{ matrix.device_id }}" ]; then
            if "$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager" list device | grep -Fq "id: ${{ matrix.device_id }}"; then
              create_cmd+=(--device "${{ matrix.device_id }}")
            else
              echo "Requested device id ${{ matrix.device_id }} not found; proceeding without explicit hardware profile"
            fi
          fi

          if ! printf 'no\n' | "${create_cmd[@]}"; then
            echo "Falling back to default hardware profile for ${{ matrix.avd }}"
            printf 'no\n' | "$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager" create avd -n ${{ matrix.avd }} -k "system-images;android-${API_LEVEL};${{ matrix.tag }};${ABI}" --force --path "${explicit_avd_dir}"
          fi

          config_candidates=()
          config_candidates+=("${explicit_avd_dir%/}/config.ini")
          if [ -n "${ANDROID_AVD_HOME:-}" ]; then
            config_candidates+=("${ANDROID_AVD_HOME%/}/${{ matrix.avd }}.avd/config.ini")
          fi
          if [ -n "${ANDROID_SDK_HOME:-}" ]; then
            config_candidates+=("${ANDROID_SDK_HOME%/}/avd/${{ matrix.avd }}.avd/config.ini")
          fi
          config_candidates+=("$HOME/.android/avd/${{ matrix.avd }}.avd/config.ini")

          avd_path=$("$ANDROID_HOME"/cmdline-tools/latest/bin/avdmanager list avd | awk -v avd="${{ matrix.avd }}" 'BEGIN{RS="";FS="\n"} $0 ~ "Name: " avd {for (i = 1; i <= NF; ++i) if ($i ~ /^Path: /) {sub(/^Path: /, "", $i); print $i; exit}}')
          if [ -n "$avd_path" ]; then
            config_candidates+=("${avd_path%/}/config.ini")
          fi

          config_path=""
          for attempt in $(seq 1 90); do
            for candidate in "${config_candidates[@]}"; do
              if [ -f "$candidate" ]; then
                config_path="$candidate"
                break 2
              fi
            done

            # avdmanager occasionally finishes before the config file is flushed to disk
            # which causes flaky failures on CI runners. Wait a moment and retry.
            sleep 2
          done

          if [ -z "$config_path" ]; then
            echo "AVD configuration not found after waiting 180 seconds. Checked:" >&2
            printf '  - %s\n' "${config_candidates[@]}" >&2
            exit 1
          fi
          if [ -n "${{ matrix.hardware_overrides }}" ]; then
            echo "Applying hardware overrides for ${{ matrix.device_label }}"
            printf '%s\n' "${{ matrix.hardware_overrides }}" >> "$config_path"
          fi

          disk_partition_args=()
          if [ -n "${{ matrix.disk_mb }}" ]; then
            requested_disk_mb=${{ matrix.disk_mb }}
            final_disk_mb=$requested_disk_mb
            available_mb=$(df -Pm "$avd_root" | awk 'NR==2 {print $4}')
            reserve_mb=2048
            # The emulator inflates the userdata image from a sparse template and
            # requires extra scratch space beyond the requested partition size.
            # Allocate additional headroom to avoid "not enough space" failures.
            partition_overhead_mb=2500

            if [[ "$available_mb" =~ ^[0-9]+$ ]]; then
              if [ "$available_mb" -le $((reserve_mb + partition_overhead_mb)) ]; then
                echo "Only ${available_mb} MB free on $avd_root; cannot allocate userdata partition." >&2
                exit 1
              fi

              safe_max=$((available_mb - reserve_mb - partition_overhead_mb))
              if [ "$safe_max" -le 0 ]; then
                echo "Insufficient disk space after reserving ${reserve_mb} MB and accounting for emulator overhead of ${partition_overhead_mb} MB (available: ${available_mb} MB)." >&2
                exit 1
              fi

              if [ "$safe_max" -lt "$final_disk_mb" ]; then
                final_disk_mb=$safe_max
                echo "Requested data partition size ${requested_disk_mb} MB exceeds available capacity (${available_mb} MB available, reserving ${reserve_mb} MB and emulator overhead ${partition_overhead_mb} MB). Using ${final_disk_mb} MB instead."
              fi
            fi

            if [ "$final_disk_mb" -le 0 ]; then
              echo "Unable to determine a valid userdata partition size (computed ${final_disk_mb} MB)." >&2
              exit 1
            fi

            echo "Configuring ${{ matrix.device_label }} data partition size to ${final_disk_mb} MB"
            if grep -q '^disk.dataPartition.size=' "$config_path"; then
              perl -0pi -e "s/^disk\\.dataPartition\\.size=.*/disk.dataPartition.size=${final_disk_mb}M/" "$config_path"
            else
              printf 'disk.dataPartition.size=%sM\n' "$final_disk_mb" >> "$config_path"
            fi
            disk_partition_args=("-partition-size" "$final_disk_mb")
          fi

          accel_args=()
          if [ "${RUNNER_OS:-}" = "macOS" ]; then
            echo "macOS runners do not expose HVF; starting emulator with -no-accel"
            accel_args=("-no-accel" "-accel" "off")
          elif ! "$ANDROID_HOME"/emulator/emulator-check accel >/dev/null 2>&1; then
            echo "Hardware acceleration unavailable; starting emulator with -no-accel"
            accel_args=("-no-accel" "-accel" "off")
          fi

          # Force a cold boot (-wipe-data) to clear stale emulator state that can lead to ANRs between runs.
          $ANDROID_HOME/emulator/emulator -avd ${{ matrix.avd }} -no-snapshot -wipe-data -no-window -gpu swiftshader_indirect -memory ${{ matrix.ram_mb }} -skin ${{ matrix.skin }} -camera-back none -camera-front none -no-boot-anim "${accel_args[@]}" "${disk_partition_args[@]}" &
          emulator_pid=$!

          device_timeout=0
          device_deadline=$((15 * 60))
          # Bootstrapping a cold AVD without hardware acceleration can take several minutes
          # before the virtual device appears to adb. Give the emulator extra time before
          # bailing out to reduce spurious CI flakes.
          while true; do
            if ! kill -0 "$emulator_pid" 2>/dev/null; then
              echo "Emulator process exited before it became available to ADB" >&2
              wait "$emulator_pid" || true
              exit 1
            fi

            if adb devices |
              tail -n +2 |
              tr -d '\r' |
              grep -qE '\sdevice$'; then
              break
            fi

            sleep 5
            device_timeout=$((device_timeout + 5))
            if [ $device_timeout -ge $device_deadline ]; then
              echo "Emulator failed to appear in adb devices output within $((device_deadline / 60)) minutes" >&2
              exit 1
            fi
          done
          boot_timeout=0
          boot_deadline=$((15 * 60))
          until adb shell getprop sys.boot_completed 2>/dev/null | grep -q "1"; do
            sleep 5
            boot_timeout=$((boot_timeout + 5))
            if ! kill -0 "$emulator_pid" 2>/dev/null; then
              echo "Emulator process exited before boot completed" >&2
              wait "$emulator_pid" || true
              exit 1
            fi
            if [ $boot_timeout -ge $boot_deadline ]; then
              echo "Emulator failed to boot within $((boot_deadline / 60)) minutes" >&2
              exit 1
            fi
          done
          adb shell settings put global window_animation_scale 0 || true
          adb shell settings put global transition_animation_scale 0 || true
          adb shell settings put global animator_duration_scale 0 || true
          adb shell input keyevent 82 || true
      - name: Install app under test
        run: |
          set -euo pipefail

          apk_path="app/build/outputs/apk/debug/app-debug.apk"

          if [ ! -f "$apk_path" ]; then
            echo "Debug APK not found; assembling it now"
            ./gradlew :app:assembleDebug --stacktrace --no-build-cache
          fi

          echo "Waiting for emulator to report as online"
          adb wait-for-device

          boot_deadline=$((5 * 60))
          boot_elapsed=0
          until adb shell getprop sys.boot_completed 2>/dev/null | tr -d '\r' | grep -q '^1$'; do
            sleep 5
            boot_elapsed=$((boot_elapsed + 5))
            if [ $boot_elapsed -ge $boot_deadline ]; then
              echo "Emulator failed to report boot completion within $((boot_deadline / 60)) minutes" >&2
              exit 1
            fi
          done

          echo "Waiting for package manager service to become available"
          pm_deadline=$((5 * 60))
          pm_elapsed=0
          until adb shell cmd package list packages >/dev/null 2>&1; do
            sleep 5
            pm_elapsed=$((pm_elapsed + 5))
            if [ $pm_elapsed -ge $pm_deadline ]; then
              echo "Package manager service did not become available within $((pm_deadline / 60)) minutes" >&2
              exit 1
            fi
          done

          echo "Installing $apk_path onto the emulator"
          install_attempt=1
          install_attempts_max=3
          while true; do
            if adb install --no-streaming -r "$apk_path"; then
              break
            fi

            if [ $install_attempt -ge $install_attempts_max ]; then
              echo "Failed to install $apk_path after $install_attempts_max attempts" >&2
              exit 1
            fi

            install_attempt=$((install_attempt + 1))
            echo "adb install failed (attempt $((install_attempt - 1))) — waiting for package manager before retrying"

            retry_deadline=$((2 * 60))
            retry_elapsed=0
            until adb shell cmd package list packages >/dev/null 2>&1; do
              sleep 5
              retry_elapsed=$((retry_elapsed + 5))
              if [ $retry_elapsed -ge $retry_deadline ]; then
                echo "Package manager did not recover within $((retry_deadline / 60)) minutes after failed install" >&2
                exit 1
              fi
            done

            sleep 5
            echo "Retrying adb install (attempt $install_attempt of $install_attempts_max)"
          done
      - name: Fetch stress PDF fixtures from S3
        id: fetch_pdfs
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          BUCKET: ${{ secrets.S3_BUCKET_NAME }}
          STRESS_PDF_KEY: ${{ vars.STRESS_PDF_S3_KEY || secrets.STRESS_PDF_S3_KEY }}
          THOUSAND_PDF_KEY: ${{ vars.THOUSAND_PAGE_PDF_S3_KEY || secrets.THOUSAND_PAGE_PDF_S3_KEY }}
          FIXTURE_DIR: ${{ github.workspace }}/instrumentation-fixtures
        run: |
          set -euo pipefail

          if [ -z "${BUCKET:-}" ]; then
            echo "::error::S3 bucket name not provided; ensure S3_BUCKET_NAME secret is set"
            exit 1
          fi

          if [ -z "${STRESS_PDF_KEY:-}" ] || [ -z "${THOUSAND_PDF_KEY:-}" ]; then
            echo "::error::Missing S3 object keys for instrumentation PDF fixtures"
            exit 1
          fi

          mkdir -p "$FIXTURE_DIR"

          download_fixture() {
            local key="$1"
            local label="$2"
            local dest="$FIXTURE_DIR/$(basename "$key")"
            local tmp="${dest}.tmp"

            echo "Downloading ${label} fixture from s3://${BUCKET}/${key}" >&2
            if ! aws s3 cp --only-show-errors "s3://${BUCKET}/${key}" "$tmp"; then
              echo "::error::Failed to download ${label} PDF fixture from s3://${BUCKET}/${key}"
              rm -f "$tmp"
              exit 1
            fi

            if [ ! -s "$tmp" ]; then
              echo "::error::Downloaded ${label} PDF fixture is empty or missing: $tmp"
              rm -f "$tmp"
              exit 1
            fi

            mv "$tmp" "$dest"
            echo "$dest"
          }

          stress_path=$(download_fixture "$STRESS_PDF_KEY" "stress")
          thousand_path=$(download_fixture "$THOUSAND_PDF_KEY" "thousand-page")

          {
            echo "stress_path=${stress_path}"
            echo "thousand_path=${thousand_path}"
          } >> "$GITHUB_OUTPUT"
      - name: Stage stress PDFs on emulator
        env:
          STRESS_DEST: stress-large.pdf
          THOUSAND_DEST: stress-thousand-pages.pdf
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail

          stress_path="${{ steps.fetch_pdfs.outputs.stress_path }}"
          thousand_path="${{ steps.fetch_pdfs.outputs.thousand_path }}"

          if [ -z "$stress_path" ] || [ -z "$thousand_path" ]; then
            echo "::error::Missing downloaded PDF fixture paths"
            exit 1
          fi

          if [ ! -s "$stress_path" ] || [ ! -s "$thousand_path" ]; then
            echo "::error::Downloaded PDF fixtures are missing or empty"
            exit 1
          fi

          adb wait-for-device

          if ! app_data_dir_output=$(adb shell run-as "$PACKAGE_NAME" sh -c 'pwd' 2>&1); then
            echo "::warning::Unable to resolve application data directory via run-as: ${app_data_dir_output}" >&2
            echo "::warning::Skipping PDF fixture staging; instrumentation will generate fixtures on-device" >&2
            exit 0
          fi

          app_data_dir=$(printf '%s' "$app_data_dir_output" | tr -d '\r' | tr -d '\n')
          if [ -z "$app_data_dir" ]; then
            echo "::warning::Application data directory is empty; skipping PDF fixture staging" >&2
            echo "::warning::Instrumentation will generate fixtures on-device" >&2
            exit 0
          fi

          echo "Application data directory resolved to $app_data_dir"

          stage_fixture() {
            local src="$1"
            local dest_name="$2"

            local cache_dir="${app_data_dir}/cache"
            local cache_path="${cache_dir}/${dest_name}"

            local staged_path=""

            if adb shell run-as "$PACKAGE_NAME" sh -c "set -e; mkdir -p \"${cache_dir}\"; cat > \"${cache_path}\"" < "$src"; then
              staged_path="$cache_path"
            else
              echo "::warning::Failed to write ${dest_name} into cache; attempting files directory fallback" >&2

              local files_dir="${app_data_dir}/files"
              local files_path="${files_dir}/${dest_name}"

              if adb shell run-as "$PACKAGE_NAME" sh -c "set -e; mkdir -p \"${files_dir}\"; cat > \"${files_path}\"" < "$src"; then
                staged_path="$files_path"
              else
                echo "::warning::Failed to stream ${dest_name} into application internal storage; instrumentation will generate it on-device" >&2
                return 0
              fi
            fi

            if [ -n "$staged_path" ] && ! adb shell run-as "$PACKAGE_NAME" sh -c "[ -s \"${staged_path}\" ]"; then
              echo "::warning::Staged ${dest_name} is missing or empty after transfer; instrumentation will regenerate it on-device" >&2
            fi
          }

          stage_fixture "$stress_path" "$STRESS_DEST"
          stage_fixture "$thousand_path" "$THOUSAND_DEST"
      - name: Run instrumentation tests against stress PDFs
        run: |
          adb logcat -c || true
          ./gradlew connectedAndroidTest --stacktrace --rerun-tasks --no-build-cache
      - name: Verify heavy PDF instrumentation coverage
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import pathlib
          import sys
          import xml.etree.ElementTree as ET

          outputs_root = pathlib.Path("app/build/outputs")
          if not outputs_root.exists():
              print("::error::Gradle outputs directory app/build/outputs not found")
              sys.exit(1)

          candidate_roots = [
              outputs_root / "androidTest-results" / "connected",
              outputs_root / "androidTest-results",
              outputs_root / "androidTestResults",
              outputs_root / "connected_android_test_additional_output",
          ]

          search_roots = [root for root in candidate_roots if root.exists()]
          if not search_roots:
              search_roots = [outputs_root]

          def is_instrumentation_report(path: pathlib.Path) -> bool:
              lowered_parts = [part.lower() for part in path.parts]
              return any("androidtest" in part for part in lowered_parts) or "connected" in lowered_parts

          report_paths = sorted(
              {
                  report
                  for root in search_roots
                  for report in root.rglob("TEST-*.xml")
                  if is_instrumentation_report(report)
              }
          )

          if not report_paths:
              print(
                  "::error::Connected Android tests did not generate any instrumentation XML reports under app/build/outputs"
              )
              sys.exit(1)

          required_tests = {
              (
                  "com.novapdf.reader.LargePdfInstrumentedTest",
                  "openLargeAndUnusualDocumentWithoutAnrOrCrash",
              ),
              (
                  "com.novapdf.reader.PdfViewerUiAutomatorTest",
                  "loadsThousandPageDocumentAndActivatesAdaptiveFlow",
              ),
          }

          executed_tests = {}

          for report in report_paths:
              try:
                  tree = ET.parse(report)
              except ET.ParseError as exc:
                  print(f"Skipping unreadable instrumentation report {report}: {exc}")
                  continue

              root = tree.getroot()
              for testcase in root.iter("testcase"):
                  key = (testcase.get("classname"), testcase.get("name"))
                  if key not in required_tests:
                      continue

                  if any(child.tag in {"failure", "error"} for child in testcase):
                      print(
                          f"::error::Required instrumentation test {key[0]}.{key[1]} failed in {report}"
                      )
                      sys.exit(1)

                  if any(child.tag == "skipped" for child in testcase) or testcase.get("status") == "skipped":
                      print(
                          f"::error::Required instrumentation test {key[0]}.{key[1]} was skipped in {report}"
                      )
                      sys.exit(1)

                  executed_tests.setdefault(key, report)

          missing = required_tests.difference(executed_tests.keys())
          if missing:
              missing_descriptions = ", ".join(f"{cls}.{name}" for cls, name in sorted(missing))
              print(
                  f"::error::Connected Android tests did not execute required instrumentation coverage for: {missing_descriptions}"
              )
              sys.exit(1)

          for key, report in sorted(executed_tests.items()):
              print(f"Confirmed {key[0]}.{key[1]} execution in {report}")
          PY
      - name: Validate ANR and crash-free logcat
        env:
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail
          adb logcat -d > logcat-after-tests.txt
          python3 - <<'PY'
          import pathlib
          import re
          import sys
          import os

          package_name = os.environ.get("PACKAGE_NAME", "com.novapdf.reader")
          escaped_package = re.escape(package_name)

          log_path = pathlib.Path("logcat-after-tests.txt")
          if not log_path.exists():
              print("::error::Unable to locate captured logcat at", log_path)
              sys.exit(1)

          contents = log_path.read_text(encoding="utf-8", errors="ignore")
          crash_signatures = [
              (
                  re.compile(rf"ANR in {escaped_package}"),
                  f"Detected Application Not Responding dialog for {package_name} during instrumentation tests",
              ),
              (
                  re.compile(rf"Application is not responding: Process {escaped_package}"),
                  f"Detected system level 'Application is not responding' warning for {package_name}",
              ),
              (
                  re.compile(rf"FATAL EXCEPTION: .*Process: {escaped_package}"),
                  f"Detected fatal crash in {package_name} during instrumentation tests",
              ),
              (
                  re.compile(r"E AndroidRuntime: FATAL EXCEPTION"),
                  "AndroidRuntime reported a fatal exception while instrumentation tests were running",
              ),
              (
                  re.compile(rf"Fatal signal \d+ .*? \(SIG[A-Z]+\).*?{escaped_package}"),
                  f"Detected native crash (fatal signal) for {package_name} during instrumentation tests",
              ),
              (
                  re.compile(rf"Process {escaped_package} has died"),
                  f"System server logged that {package_name} process died during instrumentation tests",
              ),
              (
                  re.compile(rf"Force finishing activity {escaped_package}"),
                  "Activity manager force-finished NovaPDF Reader during instrumentation tests",
              ),
          ]

          issues = [message for pattern, message in crash_signatures if pattern.search(contents)]
          if issues:
              for message in issues:
                  print(f"::error::{message}")
              sys.exit(1)

          print("Logcat is free from ANR/crash signatures")
          PY
      - name: Install debug build for screenshots
        run: |
          set -euo pipefail

          apk_path="app/build/outputs/apk/debug/app-debug.apk"

          if [ ! -f "$apk_path" ]; then
            echo "Debug APK not found; assembling it now"
            ./gradlew :app:assembleDebug --stacktrace
          fi

          echo "Waiting for emulator to report as online"
          adb wait-for-device

          boot_deadline=$((5 * 60))
          boot_elapsed=0
          until adb shell getprop sys.boot_completed 2>/dev/null | tr -d '\r' | grep -q '^1$'; do
            sleep 5
            boot_elapsed=$((boot_elapsed + 5))
            if [ $boot_elapsed -ge $boot_deadline ]; then
              echo "Emulator failed to report boot completion within $((boot_deadline / 60)) minutes" >&2
              exit 1
            fi
          done

          echo "Waiting for package manager service to become available"
          pm_deadline=$((5 * 60))
          pm_elapsed=0
          until adb shell cmd package list packages >/dev/null 2>&1; do
            sleep 5
            pm_elapsed=$((pm_elapsed + 5))
            if [ $pm_elapsed -ge $pm_deadline ]; then
              echo "Package manager service did not become available within $((pm_deadline / 60)) minutes" >&2
              exit 1
            fi
          done

          echo "Installing $apk_path onto the emulator"
          install_attempt=1
          install_attempts_max=3
          while true; do
            if adb install --no-streaming -r "$apk_path"; then
              break
            fi

            if [ $install_attempt -ge $install_attempts_max ]; then
              echo "Failed to install $apk_path after $install_attempts_max attempts" >&2
              exit 1
            fi

            install_attempt=$((install_attempt + 1))
            echo "adb install failed (attempt $((install_attempt - 1))) — waiting for package manager before retrying"

            retry_deadline=$((2 * 60))
            retry_elapsed=0
            until adb shell cmd package list packages >/dev/null 2>&1; do
              sleep 5
              retry_elapsed=$((retry_elapsed + 5))
              if [ $retry_elapsed -ge $retry_deadline ]; then
                echo "Package manager did not recover within $((retry_deadline / 60)) minutes after failed install" >&2
                exit 1
              fi
            done

            sleep 5
            echo "Retrying adb install (attempt $install_attempt of $install_attempts_max)"
          done
      - name: Install instrumentation harness for screenshots
        run: |
          set -euo pipefail

          android_test_apk="app/build/outputs/apk/androidTest/debug/app-debug-androidTest.apk"

          if [ ! -f "$android_test_apk" ]; then
            echo "AndroidTest APK not found; assembling it now"
            ./gradlew :app:assembleDebugAndroidTest --stacktrace
          fi

          echo "Installing $android_test_apk onto the emulator"
          install_attempt=1
          install_attempts_max=3
          while true; do
            if adb install --no-streaming -r -t "$android_test_apk"; then
              break
            fi

            if [ $install_attempt -ge $install_attempts_max ]; then
              echo "Failed to install $android_test_apk after $install_attempts_max attempts" >&2
              exit 1
            fi

            install_attempt=$((install_attempt + 1))
            echo "adb install failed (attempt $((install_attempt - 1))) — waiting for package manager before retrying"

            retry_deadline=$((2 * 60))
            retry_elapsed=0
            until adb shell cmd package list packages >/dev/null 2>&1; do
              sleep 5
              retry_elapsed=$((retry_elapsed + 5))
              if [ $retry_elapsed -ge $retry_deadline ]; then
                echo "Package manager did not recover within $((retry_deadline / 60)) minutes after failed install" >&2
                exit 1
              fi
            done

            sleep 5
            echo "Retrying adb install (attempt $install_attempt of $install_attempts_max)"
          done
      - name: Capture screenshots
        env:
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail

          base_dir="${ARTIFACTS_DIR}/screenshots/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$base_dir"

          READY_FLAG="cache/screenshot_ready.flag"
          DONE_FLAG="cache/screenshot_done.flag"
          HARNESS_CLASS="com.novapdf.reader.ScreenshotHarnessTest#openThousandPageDocumentForScreenshots"
          HARNESS_LOG="$base_dir/screenshot-harness.log"

          HARNESS_RUN_AS_PACKAGE="${PACKAGE_NAME}.test"

          cleanup_flags() {
            adb shell run-as "$HARNESS_RUN_AS_PACKAGE" sh -c "rm -f '$READY_FLAG' '$DONE_FLAG'" >/dev/null 2>&1 || true
          }

          cleanup_flags

          harness_pid=""
          finish_harness() {
            if [ -n "${harness_pid:-}" ] && kill -0 "$harness_pid" >/dev/null 2>&1; then
              echo "Stopping screenshot harness instrumentation" >&2
              kill "$harness_pid" >/dev/null 2>&1 || true
              wait "$harness_pid" >/dev/null 2>&1 || true
            fi
            cleanup_flags
          }
          trap finish_harness EXIT

          echo "Launching screenshot harness instrumentation to load thousand-page PDF"
          adb shell am instrument -w -r \
            -e runScreenshotHarness true \
            -e class "$HARNESS_CLASS" \
            ${PACKAGE_NAME}.test/androidx.test.runner.AndroidJUnitRunner \
            >"$HARNESS_LOG" 2>&1 &
          harness_pid=$!

          wait_for_harness() {
            local elapsed=0
            local timeout=$((5 * 60))
            while true; do
              if ! kill -0 "$harness_pid" >/dev/null 2>&1; then
                echo "::error::Screenshot harness instrumentation exited before reporting readiness" >&2
                cat "$HARNESS_LOG" >&2 || true
                wait "$harness_pid" || true
                exit 1
              fi

              if adb shell run-as "$HARNESS_RUN_AS_PACKAGE" sh -c "[ -f '$READY_FLAG' ]" >/dev/null 2>&1; then
                break
              fi

              if [ $elapsed -ge $timeout ]; then
                echo "::error::Timed out waiting for screenshot harness readiness flag" >&2
                cat "$HARNESS_LOG" >&2 || true
                exit 1
              fi

              sleep 2
              elapsed=$((elapsed + 2))
            done
          }

          wait_for_harness

          adb shell settings put system accelerometer_rotation 0 || true
          adb shell settings put system user_rotation 0 || true
          adb shell cmd uimode night no || true
          adb shell settings put secure high_text_contrast_enabled 0 || true
          adb shell settings put secure accessibility_display_daltonizer_enabled 0 || true
          sleep 5

          capture_set() {
            local label="$1"
            local orientation="$2"
            local night_mode="$3"
            local high_contrast="$4"
            local daltonizer="$5"
            local count="$6"

            local target_dir="${base_dir}/${label}"
            mkdir -p "$target_dir"

            if [ "$orientation" = "portrait" ]; then
              adb shell settings put system user_rotation 0 || true
            else
              adb shell settings put system user_rotation 1 || true
            fi

            adb shell cmd uimode night "$night_mode" || true
            adb shell settings put secure high_text_contrast_enabled "$high_contrast" || true

            if [ "$daltonizer" = "none" ]; then
              adb shell settings put secure accessibility_display_daltonizer_enabled 0 || true
            else
              adb shell settings put secure accessibility_display_daltonizer_enabled 1 || true
              adb shell settings put secure accessibility_display_daltonizer "$daltonizer" || true
            fi

            # Allow the UI to settle after changing orientation/theme/accessibility flags
            sleep 4

            for i in $(seq -w 1 "$count"); do
              adb exec-out screencap -p > "$target_dir/screenshot_${i}.png"
              sleep 1
            done
          }

          capture_set "light-portrait-standard" portrait no 0 none 5
          capture_set "light-portrait-accessibility" portrait no 1 0 4
          capture_set "dark-portrait-standard" portrait yes 0 none 4
          capture_set "dark-landscape-accessibility" landscape yes 1 1 4
          capture_set "light-landscape-standard" landscape no 0 none 3

          if ! adb shell run-as "$HARNESS_RUN_AS_PACKAGE" sh -c "printf '' > '$DONE_FLAG'" >/dev/null 2>&1; then
            echo "::error::Failed to signal screenshot harness completion" >&2
            exit 1
          fi

          if ! wait "$harness_pid"; then
            status=$?
            echo "::error::Screenshot harness instrumentation reported failure" >&2
            cat "$HARNESS_LOG" >&2 || true
            exit $status
          fi

          trap - EXIT
          finish_harness

          adb shell settings put system user_rotation 0 || true
          adb shell cmd uimode night no || true
          adb shell settings put secure high_text_contrast_enabled 0 || true
          adb shell settings put secure accessibility_display_daltonizer_enabled 0 || true
      - name: Collect emulator logs
        if: always()
        run: |
          mkdir -p "${ARTIFACTS_DIR}/logs/api${{ matrix.api }}/${{ matrix.device_label }}"
          adb logcat -d > "${ARTIFACTS_DIR}/logs/api${{ matrix.api }}/${{ matrix.device_label }}/emulator.log" || true
      - name: Stop emulator
        if: always()
        run: adb -s emulator-5554 emu kill || true
      - name: Bundle release app
        run: ./gradlew bundleRelease --stacktrace
      - name: Collect signed release bundle
        run: |
          set -euo pipefail
          bundle_path="app/build/outputs/bundle/release/app-release.aab"
          if [ ! -f "$bundle_path" ]; then
            echo "Bundle not found at $bundle_path" >&2
            exit 1
          fi
          target_dir="${ARTIFACTS_DIR}/bundles/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$target_dir"
          signed_bundle="$target_dir/NovaPDFReader-release-signed-api${{ matrix.api }}-${{ matrix.device_label }}.aab"
          cp "$bundle_path" "$signed_bundle"
          jarsigner -verify -verbose -certs "$signed_bundle"
      - name: Stage test and lint reports
        if: always()
        run: |
          mkdir -p "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}"
          if [ -d app/build/reports ]; then
            if command -v rsync >/dev/null 2>&1; then
              rsync -a app/build/reports/ "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}/"
            else
              cp -R app/build/reports/. "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}/"
            fi
          fi
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: nova-build-${{ matrix.api }}-${{ matrix.device_label }}
          path: ${{ env.ARTIFACTS_DIR }}
          if-no-files-found: warn
      - name: Upload build outputs to S3
        if: success()
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          BUCKET: ${{ secrets.S3_BUCKET_NAME }}
          S3_PREFIX: ci/${{ github.run_id }}/api${{ matrix.api }}/${{ matrix.device_label }}
        run: |
          set -euo pipefail
          if [ -d "${ARTIFACTS_DIR}/bundles/api${{ matrix.api }}/${{ matrix.device_label }}" ]; then
            aws s3 cp "${ARTIFACTS_DIR}/bundles/api${{ matrix.api }}/${{ matrix.device_label }}/" "s3://${BUCKET}/${S3_PREFIX}/bundle/" --recursive
          fi
          if [ -d "${ARTIFACTS_DIR}/screenshots/api${{ matrix.api }}/${{ matrix.device_label }}" ]; then
            aws s3 cp "${ARTIFACTS_DIR}/screenshots/api${{ matrix.api }}/${{ matrix.device_label }}/" "s3://${BUCKET}/${S3_PREFIX}/screenshots/" --recursive
          fi
          if [ -d "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}" ]; then
            aws s3 cp "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}/" "s3://${BUCKET}/${S3_PREFIX}/reports/" --recursive
          fi
          if [ -d "${ARTIFACTS_DIR}/logs/api${{ matrix.api }}/${{ matrix.device_label }}" ]; then
            aws s3 cp "${ARTIFACTS_DIR}/logs/api${{ matrix.api }}/${{ matrix.device_label }}/" "s3://${BUCKET}/${S3_PREFIX}/logs/" --recursive
          fi

  firebase-instrumentation:
    name: Firebase instrumentation (physical devices)
    runs-on: ubuntu-latest
    timeout-minutes: 120
    needs: build-test
    if: needs.build-test.result == 'success' && needs.build-test.outputs.firebase_configured == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - device_label: pixel6-physical
            model: oriole
            version: 33
          - device_label: pixel7pro-physical
            model: cheetah
            version: 33
    env:
      FIREBASE_PROJECT_ID: ${{ vars.FIREBASE_PROJECT_ID || secrets.FIREBASE_PROJECT_ID }}
    steps:
      - name: Configure Firebase results path
        run: echo "RESULTS_JSON=$RUNNER_TEMP/firebase-results.json" >> "$GITHUB_ENV"
      - name: Validate Firebase configuration
        run: |
          set -e
          if [ -z "${FIREBASE_PROJECT_ID:-}" ]; then
            echo "::error::Firebase project ID not provided; ensure FIREBASE_PROJECT_ID is configured as a repository variable or secret."
            exit 1
          fi
          if [ -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}" ]; then
            echo "::error::Firebase service account secret FIREBASE_SERVICE_ACCOUNT_JSON is missing."
            exit 1
          fi
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.FIREBASE_PROJECT_ID }}
      - name: Assemble instrumentation artifacts
        run: ./gradlew :app:assembleDebug :app:assembleDebugAndroidTest --stacktrace --no-build-cache
      - name: Run Firebase Test Lab instrumentation
        id: firebase
        env:
          DEVICE_MODEL: ${{ matrix.model }}
          DEVICE_VERSION: ${{ matrix.version }}
          DEVICE_LABEL: ${{ matrix.device_label }}
        run: |
          set -euo pipefail
          results_path="$RESULTS_JSON"
          rm -f "$results_path"

          set +e
          gcloud firebase test android run \
            --type instrumentation \
            --app app/build/outputs/apk/debug/app-debug.apk \
            --test app/build/outputs/apk/androidTest/debug/app-debug-androidTest.apk \
            --device model="$DEVICE_MODEL",version="$DEVICE_VERSION",locale=en,orientation=portrait \
            --timeout 30m \
            --num-flaky-test-attempts=1 \
            --results-history-name="ci-physical-devices" \
            --format=json > "$results_path"
          status=$?
          set -e

          if [ $status -ne 0 ]; then
            echo "::error::gcloud firebase test command failed with exit code $status"
            cat "$results_path" || true
            exit $status
          fi

          python3 - <<'PY'
            import json
            import os
            import sys

            results_path = os.environ["RESULTS_JSON"]
            with open(results_path, "r", encoding="utf-8") as fh:
                payload = json.load(fh)

            outcome = payload.get("outcomeSummary")
            storage_path = payload.get("resultStoragePath")
            matrix_id = payload.get("testMatrixId")

            print(f"Firebase Test Lab matrix {matrix_id} completed with outcome {outcome}")

            if storage_path:
                with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
                    output.write(f"storage_path={storage_path}\n")
                    output.write(f"matrix_id={matrix_id}\n")

            if outcome != "SUCCESS":
                print(f"::error::Firebase instrumentation failed with outcome {outcome}")
                sys.exit(1)
          PY
      - name: Download Firebase results
        if: always()
        env:
          STORAGE_PATH: ${{ steps.firebase.outputs.storage_path }}
          DEVICE_LABEL: ${{ matrix.device_label }}
        run: |
          set -euo pipefail
          if [ -z "${STORAGE_PATH:-}" ]; then
            echo "No Firebase results storage path found; skipping download."
            exit 0
          fi

          target_dir="firebase-results/${DEVICE_LABEL}"
          mkdir -p "$target_dir"
          gcloud storage cp --recursive "${STORAGE_PATH}/*" "$target_dir/"
      - name: Upload Firebase artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: firebase-${{ matrix.device_label }}
          path: firebase-results
          if-no-files-found: warn
