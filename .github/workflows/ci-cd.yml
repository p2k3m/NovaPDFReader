name: Android CI/CD

on:
  workflow_dispatch:
  push:
    branches: [main]
  pull_request:

concurrency:
  group: android-ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-test:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    outputs:
      firebase_configured: ${{ steps.validate_required_secrets.outputs.firebase_configured }}
    strategy:
      fail-fast: true
      max-parallel: ${{ vars.NOVAPDF_EMULATOR_MAX_PARALLEL || 1 }}
      matrix:
        include:
          - api: 32
            avd: pixel7pro_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_7_pro
            device_label: pixel-7-pro
            skin: 1440x3120
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel 7 Pro
              hw.lcd.width=1440
              hw.lcd.height=3120
              hw.lcd.density=512
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3120
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: galaxys24ultra_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_7_pro
            device_label: galaxy-s24-ultra
            skin: 1440x3120
            hardware_overrides: |
              hw.device.manufacturer=Samsung
              hw.device.name=Galaxy S24 Ultra
              hw.lcd.width=1440
              hw.lcd.height=3120
              hw.lcd.density=500
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3120
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: galaxys23ultra_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_7
            device_label: galaxy-s23-ultra
            skin: 1440x3088
            hardware_overrides: |
              hw.device.manufacturer=Samsung
              hw.device.name=Galaxy S23 Ultra
              hw.lcd.width=1440
              hw.lcd.height=3088
              hw.lcd.density=500
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3088
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: pixelfold_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_fold
            device_label: pixel-fold
            skin: 2208x1840
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel Fold
              hw.lcd.width=2208
              hw.lcd.height=1840
              hw.lcd.density=380
              hw.displayRegion.0.width=1840
              hw.displayRegion.0.height=2208
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: pixeltablet_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_tablet
            device_label: pixel-tablet
            skin: 2560x1600
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel Tablet
              hw.lcd.width=2560
              hw.lcd.height=1600
              hw.lcd.density=280
              hw.displayRegion.0.width=2560
              hw.displayRegion.0.height=1600
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
    env:
      GRADLE_OPTS: "-Dorg.gradle.jvmargs=-Xmx4g"
      ARTIFACTS_DIR: artifacts
      KEYSTORE_PATH: ${{ github.workspace }}/android-release.jks
      SIGNING_KEY_ALIAS: ${{ secrets.ANDROID_SIGNING_KEY_ALIAS }}
      SIGNING_KEY_PASSWORD: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}
      SIGNING_STORE_PASSWORD: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
      NOVAPDF_APP_ID: ${{ vars.NOVAPDF_APP_ID || secrets.NOVAPDF_APP_ID || 'com.novapdf.reader' }}
      APP_PACKAGE_NAME: ${{ vars.NOVAPDF_APP_ID || secrets.NOVAPDF_APP_ID || 'com.novapdf.reader' }}
      UNIT_TESTS_PASSED: 'false'
      NOVAPDF_ALLOW_CI_CONNECTED_TESTS: 'true'
      ACTIONS_RUNNER_DISABLE_NESTED_VIRTUALIZATION: 'true'
      ACTIONS_RUNNER_ACCELERATION_PREFERENCE: 'kvm'
      NOVAPDF_EMULATOR_GPU_MODE: ${{ vars.NOVAPDF_EMULATOR_GPU_MODE || '' }}
      NOVAPDF_EMULATOR_RAM_MB: ${{ vars.NOVAPDF_EMULATOR_RAM_MB || '' }}
      NOVAPDF_EMULATOR_READY_TIMEOUT: ${{ vars.NOVAPDF_EMULATOR_READY_TIMEOUT || 900 }}
      BASELINE_DEVICE_LABEL: pixel-7-pro
    steps:
      - name: Validate required secrets
        id: validate_required_secrets
        env:
          AWS_S3_READ_ROLE_ARN_SECRET: ${{ secrets.AWS_S3_READ_ROLE_ARN }}
          AWS_ACCESS_KEY_ID_SECRET: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY_SECRET: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME_SECRET: ${{ secrets.S3_BUCKET_NAME }}
          STRESS_PDF_KEY: ${{ vars.STRESS_PDF_S3_KEY || secrets.STRESS_PDF_S3_KEY }}
          THOUSAND_PDF_KEY: ${{ vars.THOUSAND_PAGE_PDF_S3_KEY || secrets.THOUSAND_PAGE_PDF_S3_KEY }}
          AI_PDF_SHA256_VALUE: ${{ vars.AI_PDF_SHA256 || secrets.AI_PDF_SHA256 }}
          AI_PDF_SIZE_VALUE: ${{ vars.AI_PDF_SIZE || secrets.AI_PDF_SIZE }}
          ANDROID_KEYSTORE_BASE64_SECRET: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_SIGNING_STORE_PASSWORD_SECRET: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
          ANDROID_SIGNING_KEY_ALIAS_SECRET: ${{ secrets.ANDROID_SIGNING_KEY_ALIAS }}
          ANDROID_SIGNING_KEY_PASSWORD_SECRET: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}
          FIREBASE_SERVICE_ACCOUNT_JSON_SECRET: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
          FIREBASE_PROJECT_ID_VALUE: ${{ vars.FIREBASE_PROJECT_ID || secrets.FIREBASE_PROJECT_ID }}
        run: |
          set -e
          missing=false
          firebase_missing=false
          aws_auth_mode=none
          has_access_keys=false

          if [ -n "${AWS_ACCESS_KEY_ID_SECRET:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY_SECRET:-}" ]; then
            has_access_keys=true
          fi

          if [ -n "${AWS_S3_READ_ROLE_ARN_SECRET:-}" ]; then
            aws_auth_mode=role
          elif [ "$has_access_keys" = true ]; then
            aws_auth_mode=access_keys
          fi

          if [ -z "${AWS_S3_READ_ROLE_ARN_SECRET:-}" ]; then
            if [ "$has_access_keys" = false ]; then
              echo "::error::Missing AWS_S3_READ_ROLE_ARN secret required to assume the read-only S3 role, and AWS access key credentials were not supplied as a fallback."
              echo "Remediation: Either provide an IAM role ARN via the AWS_S3_READ_ROLE_ARN repository secret, or configure long-lived credentials by storing an access key ID and secret access key as the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY repository secrets (double-check the secret names for typos)."
              missing=true
            else
              echo "::notice::AWS_S3_READ_ROLE_ARN secret not provided; will fall back to AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY credentials."
            fi
          fi

          if [ -z "${S3_BUCKET_NAME_SECRET:-}" ]; then
            echo "::error::Missing S3_BUCKET_NAME secret required for S3 access."
            echo "Remediation: Provision an S3 bucket (e.g., nova-pdf-artifacts) in the AWS console, ensure the IAM role grants s3:GetObject and s3:ListBucket permissions, then add the bucket name as the S3_BUCKET_NAME repository secret."
            missing=true
          fi

          if [ -z "${STRESS_PDF_KEY:-}" ]; then
            echo "::error::Missing STRESS_PDF_S3_KEY repository variable or secret required to download the stress PDF fixture."
            echo "Remediation: Record the S3 object key for the stress PDF (for example, fixtures/stress-large.pdf) and add it as the STRESS_PDF_S3_KEY repository variable or secret."
            missing=true
          fi

          if [ -z "${THOUSAND_PDF_KEY:-}" ]; then
            echo "::error::Missing THOUSAND_PAGE_PDF_S3_KEY repository variable or secret required to download the thousand-page PDF fixture."
            echo "Remediation: Record the S3 object key for the thousand-page PDF (for example, fixtures/stress-thousand-pages.pdf) and add it as the THOUSAND_PAGE_PDF_S3_KEY repository variable or secret."
            missing=true
          fi

          if [ -z "${AI_PDF_SHA256_VALUE:-}" ]; then
            echo "::notice::AI_PDF_SHA256 repository variable or secret not provided; the checksum will be derived automatically."
          elif ! [[ ${AI_PDF_SHA256_VALUE} =~ ^[A-Fa-f0-9]{64}$ ]]; then
            echo "::error::AI_PDF_SHA256 must be a 64-character hexadecimal SHA-256 digest."
            missing=true
          fi

          if [ -z "${AI_PDF_SIZE_VALUE:-}" ]; then
            echo "::notice::AI_PDF_SIZE repository variable or secret not provided; the size will be derived automatically."
          elif ! [[ ${AI_PDF_SIZE_VALUE} =~ ^[0-9]+$ ]]; then
            echo "::error::AI_PDF_SIZE must be an integer representing the AI.pdf object size in bytes."
            missing=true
          fi

          if [ -z "${ANDROID_KEYSTORE_BASE64_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_KEYSTORE_BASE64 secret required to sign the release bundle."
            echo "Remediation: Generate a release keystore (keytool -genkeypair -v -keystore nova-release.jks -alias nova -keyalg RSA -keysize 4096 -validity 10000), base64 encode it (base64 nova-release.jks), and save the output as the ANDROID_KEYSTORE_BASE64 repository secret."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_STORE_PASSWORD_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_STORE_PASSWORD secret required to unlock the keystore."
            echo "Remediation: Store the keystore password selected during key creation as the ANDROID_SIGNING_STORE_PASSWORD repository secret."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_KEY_ALIAS_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_KEY_ALIAS secret required for signing."
            echo "Remediation: Record the alias supplied when running keytool (e.g., nova) and add it as the ANDROID_SIGNING_KEY_ALIAS repository secret so Gradle knows which key to use."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_KEY_PASSWORD_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_KEY_PASSWORD secret required to access the signing key."
            echo "Remediation: Store the key password (often the same as the store password unless you set a separate value) as the ANDROID_SIGNING_KEY_PASSWORD repository secret."
            missing=true
          fi

          if [ -z "${FIREBASE_SERVICE_ACCOUNT_JSON_SECRET:-}" ]; then
            echo "::warning::Missing FIREBASE_SERVICE_ACCOUNT_JSON secret required for Firebase Test Lab instrumentation coverage."
            echo "Remediation: Create a Google Cloud service account with the Firebase Test Lab Admin and Storage Object Admin roles, generate a JSON key, and save the key contents as the FIREBASE_SERVICE_ACCOUNT_JSON repository secret."
            firebase_missing=true
          fi

          if [ -z "${FIREBASE_PROJECT_ID_VALUE:-}" ]; then
            echo "::warning::Missing FIREBASE_PROJECT_ID repository variable or secret required to target the Firebase project for physical device testing."
            echo "Remediation: Note the Google Cloud project ID that hosts Firebase Test Lab (e.g., nova-pdf-prod) and store it either as the FIREBASE_PROJECT_ID repository variable or secret."
            firebase_missing=true
          fi

          echo "aws_auth_mode=${aws_auth_mode}" >> "$GITHUB_OUTPUT"

          if [ "$firebase_missing" = true ]; then
            echo "::notice::Firebase secrets missing; Firebase Test Lab jobs will be skipped."
            echo "firebase_configured=false" >> "$GITHUB_OUTPUT"
          else
            echo "firebase_configured=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Mask sensitive environment variables
        if: ${{ steps.validate_required_secrets.outcome == 'success' }}
        env:
          AWS_S3_READ_ROLE_ARN: ${{ secrets.AWS_S3_READ_ROLE_ARN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          STRESS_PDF_S3_KEY: ${{ vars.STRESS_PDF_S3_KEY || secrets.STRESS_PDF_S3_KEY }}
          THOUSAND_PAGE_PDF_S3_KEY: ${{ vars.THOUSAND_PAGE_PDF_S3_KEY || secrets.THOUSAND_PAGE_PDF_S3_KEY }}
          AI_PDF_SHA256: ${{ vars.AI_PDF_SHA256 || secrets.AI_PDF_SHA256 }}
          AI_PDF_SIZE: ${{ vars.AI_PDF_SIZE || secrets.AI_PDF_SIZE }}
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_SIGNING_STORE_PASSWORD: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
          ANDROID_SIGNING_KEY_ALIAS: ${{ secrets.ANDROID_SIGNING_KEY_ALIAS }}
          ANDROID_SIGNING_KEY_PASSWORD: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}
          FIREBASE_SERVICE_ACCOUNT_JSON: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
          FIREBASE_PROJECT_ID: ${{ vars.FIREBASE_PROJECT_ID || secrets.FIREBASE_PROJECT_ID }}
        shell: bash
        run: |
          set +e
          for var in \
            AWS_S3_READ_ROLE_ARN \
            AWS_ACCESS_KEY_ID \
            AWS_SECRET_ACCESS_KEY \
            STRESS_PDF_S3_KEY \
            THOUSAND_PAGE_PDF_S3_KEY \
            AI_PDF_SHA256 \
            AI_PDF_SIZE \
            ANDROID_KEYSTORE_BASE64 \
            ANDROID_SIGNING_STORE_PASSWORD \
            ANDROID_SIGNING_KEY_ALIAS \
            ANDROID_SIGNING_KEY_PASSWORD \
            FIREBASE_SERVICE_ACCOUNT_JSON \
            FIREBASE_PROJECT_ID
          do
            value="${!var:-}"
            if [[ -n "$value" ]]; then
              echo "::add-mask::$value"
            fi
          done

          if [ "$missing" = true ]; then
            exit 1
          fi
      - uses: actions/checkout@v4
      - name: Check baseline profile freshness
        id: baseline_profile_freshness
        if: github.event_name == 'pull_request'
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref }}
        run: |
          set -euo pipefail

          baseline_outputs="$GITHUB_OUTPUT"
          summary_path="${GITHUB_STEP_SUMMARY:-}"

          emit_skip() {
            local message="$1"
            {
              printf 'baseline_touched=false\n'
              printf 'needs_profile=false\n'
              printf 'reminder=false\n'
              printf 'skipped=true\n'
              printf 'message<<__BASELINE_MESSAGE__\n'
              printf '%s\n' "$message"
              printf '__BASELINE_MESSAGE__\n'
            } >>"$baseline_outputs"

            if [ -n "$summary_path" ]; then
              {
                printf '## Baseline profile reminder\n'
                printf '%s\n' "$message"
              } >>"$summary_path"
            fi

            local encoded="${message//%/%25}"
            encoded="${encoded//$'\r'/%0D}"
            encoded="${encoded//$'\n'/%0A}"
            echo "::notice::${encoded}"
          }

          if [ -z "${BASE_REF:-}" ]; then
            emit_skip "Skipping baseline profile reminder because the pull request base ref is unavailable."
            exit 0
          fi

          if ! git fetch --no-tags --depth=50 origin "$BASE_REF"; then
            emit_skip "Unable to fetch origin/${BASE_REF} to evaluate baseline profile freshness; skipping reminder check."
            exit 0
          fi

          python3 tools/scripts/baseline_profile_guard.py \
            --base "origin/${BASE_REF}" \
            --github-output "$baseline_outputs" \
            --github-step-summary "$summary_path"
      - name: Comment on baseline profile reminder
        if: github.event_name == 'pull_request' && steps.baseline_profile_freshness.outputs.reminder == 'true'
        uses: actions/github-script@v7
        env:
          REMINDER_MESSAGE: ${{ steps.baseline_profile_freshness.outputs.message }}
        with:
          script: |
            const marker = '<!-- baseline-profile-reminder -->';
            const reminderMessage = (process.env.REMINDER_MESSAGE || '').trim();

            if (!reminderMessage) {
              core.info('Reminder message was empty; skipping comment.');
              return;
            }

            const body = `${marker}\n⚠️ ${reminderMessage}`;
            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number,
              per_page: 100,
            });

            const existing = comments.find((comment) =>
              comment.body.includes(marker) && comment.user?.type === 'Bot'
            );

            if (existing) {
              if (existing.body.trim() === body.trim()) {
                core.info('Baseline profile reminder comment already up to date.');
                return;
              }

              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body,
              });
              core.info('Updated existing baseline profile reminder comment.');
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body,
            });
            core.info('Created baseline profile reminder comment.');
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            gradle-
      - name: Grant execute permission for Gradle
        run: chmod +x gradlew
      - name: Run static analysis and style checks
        run: ./gradlew detekt spotlessCheck
      - name: Decode signing keystore
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
        run: |
          set -euo pipefail
          echo "Decoding Android signing keystore to $KEYSTORE_PATH"
          python3 -c "import base64, os; encoded = os.environ['ANDROID_KEYSTORE_BASE64'].strip().encode(); path = os.environ['KEYSTORE_PATH']; open(path, 'wb').write(base64.b64decode(encoded))"
          chmod 600 "$KEYSTORE_PATH"
      - name: Download Android SDK components
        env:
          API_LEVEL: ${{ matrix.api }}
          ABI: ${{ matrix.abi }}
          TAG: ${{ matrix.tag }}
        run: |
          set -euo pipefail

          SDKMANAGER="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"

          disable_pipefail() {
            set +o pipefail 2>/dev/null || true
          }

          enable_pipefail() {
            set -o pipefail 2>/dev/null || true
          }

          disable_pipefail
          yes | "$SDKMANAGER" --licenses
          enable_pipefail

          packages=(
            "platform-tools"
            "platforms;android-${API_LEVEL}"
            "system-images;android-${API_LEVEL};${TAG};${ABI}"
            "build-tools;34.0.0"
            "emulator"
          )

          attempt=1
          max_attempts=3
          while true; do
            disable_pipefail
            if yes | "$SDKMANAGER" "${packages[@]}"; then
              enable_pipefail
              break
            fi

            exit_code=$?
            enable_pipefail
            if (( attempt >= max_attempts )); then
              echo "::error::Failed to install Android SDK packages after ${attempt} attempts (exit code ${exit_code})."
              exit "${exit_code}"
            fi

            echo "Attempt ${attempt} to install Android SDK packages failed with exit code ${exit_code}. Cleaning partial downloads and retrying..."
            rm -rf "$ANDROID_HOME/system-images/android-${API_LEVEL}/${TAG}/${ABI}" || true
            rm -rf "$ANDROID_HOME/emulator" || true
            rm -rf "$HOME/.android/cache" || true

            attempt=$(( attempt + 1 ))
            sleep $(( attempt * 5 ))
          done
      - name: Add Android platform tools to PATH
        run: echo "$ANDROID_HOME/platform-tools" >> "$GITHUB_PATH"
      - name: Configure AWS credentials (assume role)
        if: ${{ steps.validate_required_secrets.outputs.aws_auth_mode == 'role' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_S3_READ_ROLE_ARN }}
          role-session-name: GitHubActionsS3ReadOnly
          aws-region: us-east-1
          mask-aws-account-id: true
          inline-session-policy: |
            {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Sid": "ReadOnlyFixturesBucket",
                  "Effect": "Allow",
                  "Action": [
                    "s3:GetObject",
                    "s3:GetObjectVersion",
                    "s3:ListBucket"
                  ],
                  "Resource": [
                    "arn:aws:s3:::${{ secrets.S3_BUCKET_NAME }}",
                    "arn:aws:s3:::${{ secrets.S3_BUCKET_NAME }}/*",
                    "arn:aws:s3:::${{ vars.AI_PDF_BUCKET || 'pics-1234' }}",
                    "arn:aws:s3:::${{ vars.AI_PDF_BUCKET || 'pics-1234' }}/*"
                  ]
                }
              ]
            }
      - name: Configure AWS credentials (access keys)
        if: ${{ steps.validate_required_secrets.outputs.aws_auth_mode == 'access_keys' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - name: Validate AWS credentials
        run: |
          set -euo pipefail
          aws sts get-caller-identity --query 'Account' --output text >/dev/null
      - name: Resolve AI.pdf metadata
        id: ai_pdf_metadata
        env:
          AI_PDF_BUCKET: ${{ vars.AI_PDF_BUCKET || 'pics-1234' }}
          AI_PDF_KEY: ${{ vars.AI_PDF_KEY || 'AI.pdf' }}
        run: |
          set -euo pipefail

          bucket="${AI_PDF_BUCKET:-}"
          key="${AI_PDF_KEY:-}"

          if [ -z "$bucket" ] || [ -z "$key" ]; then
            echo "::error::AI.pdf bucket or key is empty. Set AI_PDF_BUCKET and AI_PDF_KEY repository variables if the defaults are incorrect."
            exit 1
          fi

          cache_dir="$RUNNER_TEMP/ai-pdf-cache"
          mkdir -p "$cache_dir"

          etag=""
          metadata_size=""
          metadata_checksum=""
          if metadata_json=$(aws s3api head-object --bucket "$bucket" --key "$key" --output json 2>/dev/null); then
            python_script=$(printf '%s\n' \
              "import base64" \
              "import json" \
              "import sys" \
              "" \
              "data = json.load(sys.stdin)" \
              "" \
              "etag = (data.get(\"ETag\") or \"\").strip('\"')" \
              "size = data.get(\"ContentLength\")" \
              "checksum = data.get(\"ChecksumSHA256\") or \"\"" \
              "" \
              "if checksum:" \
              "    try:" \
              "        checksum = base64.b64decode(checksum).hex()" \
              "    except Exception:" \
              "        checksum = \"\"" \
              "" \
              "print(etag)" \
              "print(\"\" if size is None else size)" \
              "print(checksum)"
            )
            readarray -t metadata_fields < <(python3 -c "$python_script" <<< "$metadata_json")
            etag="${metadata_fields[0]:-}"
            metadata_size="${metadata_fields[1]:-}"
            metadata_checksum="${metadata_fields[2]:-}"
          else
            echo "::warning::Unable to retrieve AI.pdf metadata via aws s3api head-object; caching and automatic defaults may be limited."
          fi

          cache_enabled="false"
          cache_key="ai-pdf-no-etag"
          if [ -n "$etag" ]; then
            cache_enabled="true"
            cache_key="ai-pdf-${etag}"
          fi

          {
            echo "cache_dir=${cache_dir}"
            echo "dest_path=${cache_dir}/AI.pdf"
            echo "cache_key=${cache_key}"
            echo "cache_enabled=${cache_enabled}"
            echo "etag=${etag}"
            echo "bucket=${bucket}"
            echo "key=${key}"
            echo "metadata_size=${metadata_size}"
            echo "metadata_checksum=${metadata_checksum}"
          } >> "$GITHUB_OUTPUT"
      - name: Restore AI.pdf cache
        if: steps.ai_pdf_metadata.outputs.cache_enabled == 'true'
        id: ai_pdf_cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.ai_pdf_metadata.outputs.cache_dir }}
          key: ${{ steps.ai_pdf_metadata.outputs.cache_key }}
      - name: Download AI.pdf fixture
        id: download_ai_pdf
        env:
          AI_PDF_BUCKET: ${{ vars.AI_PDF_BUCKET || 'pics-1234' }}
          AI_PDF_KEY: ${{ vars.AI_PDF_KEY || 'AI.pdf' }}
          AI_PDF_SHA256: ${{ vars.AI_PDF_SHA256 || secrets.AI_PDF_SHA256 }}
          AI_PDF_SIZE: ${{ vars.AI_PDF_SIZE || secrets.AI_PDF_SIZE }}
          AI_PDF_DEST: ${{ steps.ai_pdf_metadata.outputs.dest_path }}
          AI_PDF_CACHE_HIT: ${{ steps.ai_pdf_cache.outputs.cache-hit }}
          AI_PDF_METADATA_SIZE: ${{ steps.ai_pdf_metadata.outputs.metadata_size }}
          AI_PDF_METADATA_CHECKSUM: ${{ steps.ai_pdf_metadata.outputs.metadata_checksum }}
        run: |
          set -euo pipefail

          bucket="${AI_PDF_BUCKET:-}"
          key="${AI_PDF_KEY:-}"
          expected_sha="${AI_PDF_SHA256:-}"
          expected_size="${AI_PDF_SIZE:-}"
          metadata_size="${AI_PDF_METADATA_SIZE:-}"
          metadata_checksum="${AI_PDF_METADATA_CHECKSUM:-}"

          if [ -z "$bucket" ] || [ -z "$key" ]; then
            echo "::error::AI.pdf bucket or key is empty. Set AI_PDF_BUCKET and AI_PDF_KEY repository variables if the defaults are incorrect."
            exit 1
          fi

          dest="${AI_PDF_DEST:-}"
          if [ -z "$dest" ]; then
            echo "::error::AI.pdf destination path is not defined."
            exit 1
          fi

          tmp="${dest}.tmp"
          trap 'rm -f "$tmp"' EXIT

          if [ -z "$expected_size" ] && [ -n "$metadata_size" ]; then
            echo "::notice::Using AI.pdf size ${metadata_size} bytes from S3 metadata as the expected value."
            expected_size="$metadata_size"
          fi

          normalized_expected_sha=""
          if [ -z "$expected_sha" ] && [ -n "$metadata_checksum" ]; then
            echo "::notice::Using AI.pdf checksum derived from S3 metadata as the expected value."
            expected_sha="$metadata_checksum"
          fi

          if [ -n "$expected_sha" ]; then
            normalized_expected_sha=$(printf '%s' "$expected_sha" | tr '[:upper:]' '[:lower:]')
          fi
          cache_hit="${AI_PDF_CACHE_HIT:-false}"

          download_ai_pdf() {
            echo "Downloading AI.pdf fixture from s3://${bucket}/${key}" >&2
            if ! aws s3 cp --only-show-errors "s3://${bucket}/${key}" "$tmp"; then
              echo "::error::Failed to download AI.pdf fixture from s3://${bucket}/${key}" >&2
              exit 1
            fi

            if [ ! -s "$tmp" ]; then
              echo "::error::Downloaded AI.pdf fixture is empty: $tmp" >&2
              exit 1
            fi

            mv "$tmp" "$dest"
          }

          last_error=""
          verify_ai_pdf() {
            local path="$1"

            if [ ! -s "$path" ]; then
              last_error="AI.pdf is missing or empty at $path"
              return 1
            fi

            local actual_size
            actual_size=$(stat -c%s "$path")
            if [ -z "$expected_size" ]; then
              echo "::notice::AI.pdf size not supplied; using downloaded size ${actual_size} bytes."
              expected_size="$actual_size"
            elif [ "$actual_size" -ne "$expected_size" ]; then
              last_error="AI.pdf size mismatch. Expected ${expected_size} bytes but found ${actual_size} bytes."
              return 1
            fi

            local actual_sha
            actual_sha=$(sha256sum "$path" | awk '{print $1}')
            if [ -z "$normalized_expected_sha" ]; then
              echo "::notice::AI.pdf checksum not supplied; using downloaded checksum ${actual_sha}."
              normalized_expected_sha="$actual_sha"
            elif [ "$actual_sha" != "$normalized_expected_sha" ]; then
              last_error="AI.pdf SHA-256 mismatch. Expected ${normalized_expected_sha} but found ${actual_sha}."
              return 1
            fi

            last_error=""
            return 0
          }

          if [ -s "$dest" ] && verify_ai_pdf "$dest"; then
            echo "AI.pdf fixture satisfied integrity checks from cache (cache hit: ${cache_hit})." >&2
          else
            if [ -s "$dest" ]; then
              echo "::warning::Cached AI.pdf failed validation: ${last_error:-unknown reason}. Fetching a fresh copy." >&2
            elif [ "$cache_hit" = "true" ]; then
              echo "::warning::Cache indicated a hit but AI.pdf was missing. Fetching a fresh copy." >&2
            fi

            rm -f "$dest"
            download_ai_pdf

            if ! verify_ai_pdf "$dest"; then
              echo "::error::Failed to verify AI.pdf after download: ${last_error:-unknown reason}." >&2
              exit 1
            fi
          fi

          trap - EXIT
          rm -f "$tmp"

          echo "ai_pdf_path=$dest" >> "$GITHUB_OUTPUT"
          if [ -n "$expected_size" ]; then
            echo "ai_pdf_size=$expected_size" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$normalized_expected_sha" ]; then
            echo "ai_pdf_sha256=$normalized_expected_sha" >> "$GITHUB_OUTPUT"
          fi
          echo "AI_PDF_PATH=$dest" >> "$GITHUB_ENV"
      - name: Run unit tests
        id: unit_tests
        run: |
          set -euo pipefail
          ./gradlew testDebugUnitTest --info
          echo "UNIT_TESTS_PASSED=true" >> "$GITHUB_ENV"
      - name: Abort workflow after failure
        if: ${{ failure() }}
        run: |
          echo "::error::A previous step failed. Stopping remaining workflow steps."
          exit 1

  heavy-pdf-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    needs: build-test
    if: needs.build-test.result == 'success'
    strategy:
      fail-fast: true
      max-parallel: ${{ vars.NOVAPDF_EMULATOR_MAX_PARALLEL || 1 }}
      matrix:
        include:
          - api: 32
            avd: pixel7pro_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_7_pro
            device_label: pixel-7-pro
            skin: 1440x3120
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel 7 Pro
              hw.lcd.width=1440
              hw.lcd.height=3120
              hw.lcd.density=512
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3120
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: galaxys24ultra_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_7_pro
            device_label: galaxy-s24-ultra
            skin: 1440x3120
            hardware_overrides: |
              hw.device.manufacturer=Samsung
              hw.device.name=Galaxy S24 Ultra
              hw.lcd.width=1440
              hw.lcd.height=3120
              hw.lcd.density=500
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3120
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: galaxys23ultra_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_7
            device_label: galaxy-s23-ultra
            skin: 1440x3088
            hardware_overrides: |
              hw.device.manufacturer=Samsung
              hw.device.name=Galaxy S23 Ultra
              hw.lcd.width=1440
              hw.lcd.height=3088
              hw.lcd.density=500
              hw.displayRegion.0.width=1440
              hw.displayRegion.0.height=3088
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: pixelfold_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_fold
            device_label: pixel-fold
            skin: 2208x1840
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel Fold
              hw.lcd.width=2208
              hw.lcd.height=1840
              hw.lcd.density=380
              hw.displayRegion.0.width=1840
              hw.displayRegion.0.height=2208
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
          - api: 32
            avd: pixeltablet_api32
            tag: google_apis
            abi: x86_64
            ram_mb: 14336
            gpu_mode: swiftshader_indirect
            disk_mb: 16384
            device_id: pixel_tablet
            device_label: pixel-tablet
            skin: 2560x1600
            hardware_overrides: |
              hw.device.manufacturer=Google
              hw.device.name=Pixel Tablet
              hw.lcd.width=2560
              hw.lcd.height=1600
              hw.lcd.density=280
              hw.displayRegion.0.width=2560
              hw.displayRegion.0.height=1600
              hw.displayRegion.0.xOffset=0
              hw.displayRegion.0.yOffset=0
    env:
      GRADLE_OPTS: "-Dorg.gradle.jvmargs=-Xmx4g"
      ARTIFACTS_DIR: artifacts
      KEYSTORE_PATH: ${{ github.workspace }}/android-release.jks
      SIGNING_KEY_ALIAS: ${{ secrets.ANDROID_SIGNING_KEY_ALIAS }}
      SIGNING_KEY_PASSWORD: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}
      SIGNING_STORE_PASSWORD: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
      NOVAPDF_APP_ID: ${{ vars.NOVAPDF_APP_ID || secrets.NOVAPDF_APP_ID || 'com.novapdf.reader' }}
      APP_PACKAGE_NAME: ${{ vars.NOVAPDF_APP_ID || secrets.NOVAPDF_APP_ID || 'com.novapdf.reader' }}
      UNIT_TESTS_PASSED: 'true'
      NOVAPDF_ALLOW_CI_CONNECTED_TESTS: 'true'
      ACTIONS_RUNNER_DISABLE_NESTED_VIRTUALIZATION: 'true'
      ACTIONS_RUNNER_ACCELERATION_PREFERENCE: 'kvm'
      NOVAPDF_EMULATOR_GPU_MODE: ${{ vars.NOVAPDF_EMULATOR_GPU_MODE || '' }}
      NOVAPDF_EMULATOR_RAM_MB: ${{ vars.NOVAPDF_EMULATOR_RAM_MB || '' }}
      NOVAPDF_EMULATOR_READY_TIMEOUT: ${{ vars.NOVAPDF_EMULATOR_READY_TIMEOUT || 900 }}
    steps:
      - name: Validate required secrets
        id: validate_required_secrets
        env:
          AWS_S3_READ_ROLE_ARN_SECRET: ${{ secrets.AWS_S3_READ_ROLE_ARN }}
          AWS_ACCESS_KEY_ID_SECRET: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY_SECRET: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME_SECRET: ${{ secrets.S3_BUCKET_NAME }}
          STRESS_PDF_KEY: ${{ vars.STRESS_PDF_S3_KEY || secrets.STRESS_PDF_S3_KEY }}
          THOUSAND_PDF_KEY: ${{ vars.THOUSAND_PAGE_PDF_S3_KEY || secrets.THOUSAND_PAGE_PDF_S3_KEY }}
          AI_PDF_SHA256_VALUE: ${{ vars.AI_PDF_SHA256 || secrets.AI_PDF_SHA256 }}
          AI_PDF_SIZE_VALUE: ${{ vars.AI_PDF_SIZE || secrets.AI_PDF_SIZE }}
          ANDROID_KEYSTORE_BASE64_SECRET: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_SIGNING_STORE_PASSWORD_SECRET: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
          ANDROID_SIGNING_KEY_ALIAS_SECRET: ${{ secrets.ANDROID_SIGNING_KEY_ALIAS }}
          ANDROID_SIGNING_KEY_PASSWORD_SECRET: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}
          FIREBASE_SERVICE_ACCOUNT_JSON_SECRET: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
          FIREBASE_PROJECT_ID_VALUE: ${{ vars.FIREBASE_PROJECT_ID || secrets.FIREBASE_PROJECT_ID }}
        run: |
          set -e
          missing=false
          firebase_missing=false
          aws_auth_mode=none
          has_access_keys=false

          if [ -n "${AWS_ACCESS_KEY_ID_SECRET:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY_SECRET:-}" ]; then
            has_access_keys=true
          fi

          if [ -n "${AWS_S3_READ_ROLE_ARN_SECRET:-}" ]; then
            aws_auth_mode=role
          elif [ "$has_access_keys" = true ]; then
            aws_auth_mode=access_keys
          fi

          if [ -z "${AWS_S3_READ_ROLE_ARN_SECRET:-}" ]; then
            if [ "$has_access_keys" = false ]; then
              echo "::error::Missing AWS_S3_READ_ROLE_ARN secret required to assume the read-only S3 role, and AWS access key credentials were not supplied as a fallback."
              echo "Remediation: Either provide an IAM role ARN via the AWS_S3_READ_ROLE_ARN repository secret, or configure long-lived credentials by storing an access key ID and secret access key as the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY repository secrets (double-check the secret names for typos)."
              missing=true
            else
              echo "::notice::AWS_S3_READ_ROLE_ARN secret not provided; will fall back to AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY credentials."
            fi
          fi

          if [ -z "${S3_BUCKET_NAME_SECRET:-}" ]; then
            echo "::error::Missing S3_BUCKET_NAME secret required for S3 access."
            missing=true
          fi

          if [ -z "${STRESS_PDF_KEY:-}" ]; then
            echo "::error::Missing STRESS_PDF_S3_KEY repository variable or secret required to download the stress PDF fixture."
            missing=true
          fi

          if [ -z "${THOUSAND_PDF_KEY:-}" ]; then
            echo "::error::Missing THOUSAND_PAGE_PDF_S3_KEY repository variable or secret required to download the thousand-page PDF fixture."
            missing=true
          fi

          if [ -z "${AI_PDF_SHA256_VALUE:-}" ]; then
            echo "::notice::AI_PDF_SHA256 repository variable or secret not provided; the checksum will be derived automatically."
          elif ! [[ ${AI_PDF_SHA256_VALUE} =~ ^[A-Fa-f0-9]{64}$ ]]; then
            echo "::error::AI_PDF_SHA256 must be a 64-character hexadecimal SHA-256 digest."
            missing=true
          fi

          if [ -z "${AI_PDF_SIZE_VALUE:-}" ]; then
            echo "::notice::AI_PDF_SIZE repository variable or secret not provided; the size will be derived automatically."
          elif ! [[ ${AI_PDF_SIZE_VALUE} =~ ^[0-9]+$ ]]; then
            echo "::error::AI_PDF_SIZE must be an integer representing the AI.pdf object size in bytes."
            missing=true
          fi

          if [ -z "${ANDROID_KEYSTORE_BASE64_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_KEYSTORE_BASE64 secret required to sign the release bundle."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_STORE_PASSWORD_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_STORE_PASSWORD secret required to unlock the keystore."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_KEY_ALIAS_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_KEY_ALIAS secret required for signing."
            missing=true
          fi

          if [ -z "${ANDROID_SIGNING_KEY_PASSWORD_SECRET:-}" ]; then
            echo "::error::Missing ANDROID_SIGNING_KEY_PASSWORD secret required to access the signing key."
            missing=true
          fi

          if [ -z "${FIREBASE_SERVICE_ACCOUNT_JSON_SECRET:-}" ]; then
            echo "::warning::Missing FIREBASE_SERVICE_ACCOUNT_JSON secret required for Firebase Test Lab instrumentation coverage."
            firebase_missing=true
          fi

          if [ -z "${FIREBASE_PROJECT_ID_VALUE:-}" ]; then
            echo "::warning::Missing FIREBASE_PROJECT_ID repository variable or secret required to target the Firebase project for physical device testing."
            firebase_missing=true
          fi

          echo "aws_auth_mode=${aws_auth_mode}" >> "$GITHUB_OUTPUT"

          if [ "$firebase_missing" = true ]; then
            echo "::notice::Firebase secrets missing; Firebase Test Lab jobs will be skipped."
            echo "firebase_configured=false" >> "$GITHUB_OUTPUT"
          else
            echo "firebase_configured=true" >> "$GITHUB_OUTPUT"
          fi

          if [ "$missing" = true ]; then
            exit 1
          fi
      - name: Mask sensitive environment variables
        if: ${{ steps.validate_required_secrets.outcome == 'success' }}
        env:
          AWS_S3_READ_ROLE_ARN: ${{ secrets.AWS_S3_READ_ROLE_ARN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          STRESS_PDF_S3_KEY: ${{ vars.STRESS_PDF_S3_KEY || secrets.STRESS_PDF_S3_KEY }}
          THOUSAND_PAGE_PDF_S3_KEY: ${{ vars.THOUSAND_PAGE_PDF_S3_KEY || secrets.THOUSAND_PAGE_PDF_S3_KEY }}
          AI_PDF_SHA256: ${{ vars.AI_PDF_SHA256 || secrets.AI_PDF_SHA256 }}
          AI_PDF_SIZE: ${{ vars.AI_PDF_SIZE || secrets.AI_PDF_SIZE }}
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_SIGNING_STORE_PASSWORD: ${{ secrets.ANDROID_SIGNING_STORE_PASSWORD }}
          ANDROID_SIGNING_KEY_ALIAS: ${{ secrets.ANDROID_SIGNING_KEY_ALIAS }}
          ANDROID_SIGNING_KEY_PASSWORD: ${{ secrets.ANDROID_SIGNING_KEY_PASSWORD }}
          FIREBASE_SERVICE_ACCOUNT_JSON: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
          FIREBASE_PROJECT_ID: ${{ vars.FIREBASE_PROJECT_ID || secrets.FIREBASE_PROJECT_ID }}
        shell: bash
        run: |
          set +e
          for var in \
            AWS_S3_READ_ROLE_ARN \
            AWS_ACCESS_KEY_ID \
            AWS_SECRET_ACCESS_KEY \
            STRESS_PDF_S3_KEY \
            THOUSAND_PAGE_PDF_S3_KEY \
            AI_PDF_SHA256 \
            AI_PDF_SIZE \
            ANDROID_KEYSTORE_BASE64 \
            ANDROID_SIGNING_STORE_PASSWORD \
            ANDROID_SIGNING_KEY_ALIAS \
            ANDROID_SIGNING_KEY_PASSWORD \
            FIREBASE_SERVICE_ACCOUNT_JSON \
            FIREBASE_PROJECT_ID
          do
            value="${!var:-}"
            if [[ -n "$value" ]]; then
              echo "::add-mask::$value"
            fi
          done
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            gradle-
      - name: Grant execute permission for Gradle
        run: chmod +x gradlew
      - name: Decode signing keystore
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
        run: |
          set -euo pipefail
          echo "Decoding Android signing keystore to $KEYSTORE_PATH"
          python3 -c "import base64, os; encoded = os.environ['ANDROID_KEYSTORE_BASE64'].strip().encode(); path = os.environ['KEYSTORE_PATH']; open(path, 'wb').write(base64.b64decode(encoded))"
          chmod 600 "$KEYSTORE_PATH"
      - name: Download Android SDK components
        env:
          API_LEVEL: ${{ matrix.api }}
          ABI: ${{ matrix.abi }}
          TAG: ${{ matrix.tag }}
        run: |
          set -euo pipefail

          SDKMANAGER="$ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager"

          disable_pipefail() {
            set +o pipefail 2>/dev/null || true
          }

          enable_pipefail() {
            set -o pipefail 2>/dev/null || true
          }

          disable_pipefail
          yes | "$SDKMANAGER" --licenses
          enable_pipefail

          packages=(
            "platform-tools"
            "platforms;android-${API_LEVEL}"
            "system-images;android-${API_LEVEL};${TAG};${ABI}"
            "build-tools;34.0.0"
            "emulator"
          )

          attempt=1
          max_attempts=3
          while true; do
            disable_pipefail
            if yes | "$SDKMANAGER" "${packages[@]}"; then
              enable_pipefail
              break
            fi

            exit_code=$?
            enable_pipefail
            if (( attempt >= max_attempts )); then
              echo "::error::Failed to install Android SDK packages after ${attempt} attempts (exit code ${exit_code})."
              exit "${exit_code}"
            fi

            echo "Attempt ${attempt} to install Android SDK packages failed with exit code ${exit_code}. Cleaning partial downloads and retrying..."
            rm -rf "$ANDROID_HOME/system-images/android-${API_LEVEL}/${TAG}/${ABI}" || true
            rm -rf "$ANDROID_HOME/emulator" || true
            rm -rf "$HOME/.android/cache" || true

            attempt=$(( attempt + 1 ))
            sleep $(( attempt * 5 ))
          done
      - name: Add Android platform tools to PATH
        run: echo "$ANDROID_HOME/platform-tools" >> "$GITHUB_PATH"
      - name: Configure AWS credentials (assume role)
        if: ${{ steps.validate_required_secrets.outputs.aws_auth_mode == 'role' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_S3_READ_ROLE_ARN }}
          role-session-name: GitHubActionsS3ReadOnly
          aws-region: us-east-1
          mask-aws-account-id: true
          inline-session-policy: |
            {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Sid": "ReadOnlyFixturesBucket",
                  "Effect": "Allow",
                  "Action": [
                    "s3:GetObject",
                    "s3:GetObjectVersion",
                    "s3:ListBucket"
                  ],
                  "Resource": [
                    "arn:aws:s3:::${{ secrets.S3_BUCKET_NAME }}",
                    "arn:aws:s3:::${{ secrets.S3_BUCKET_NAME }}/*",
                    "arn:aws:s3:::${{ vars.AI_PDF_BUCKET || 'pics-1234' }}",
                    "arn:aws:s3:::${{ vars.AI_PDF_BUCKET || 'pics-1234' }}/*"
                  ]
                }
              ]
            }
      - name: Configure AWS credentials (access keys)
        if: ${{ steps.validate_required_secrets.outputs.aws_auth_mode == 'access_keys' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - name: Validate AWS credentials
        run: |
          set -euo pipefail
          aws sts get-caller-identity --query 'Account' --output text >/dev/null
      - name: Start emulator
        env:
          API_LEVEL: ${{ matrix.api }}
          ABI: ${{ matrix.abi }}
          RUNNER_OS: ${{ runner.os }}
          GPU_MODE: ${{ matrix.gpu_mode || 'swiftshader_indirect' }}
          EMULATOR_RAM_MB: ${{ matrix.ram_mb }}
        run: |
          set -euo pipefail

          print_host_memory_stats() {
            echo "Host memory snapshot ($(date -u '+%Y-%m-%dT%H:%M:%SZ'))"
            if command -v free >/dev/null 2>&1; then
              free -h || true
            elif command -v vm_stat >/dev/null 2>&1; then
              vm_stat || true
            else
              echo "free/vm_stat utilities unavailable on host" >&2
            fi
          }

          echo "Capturing host memory snapshot before emulator provisioning"
          print_host_memory_stats

          if [ -n "${ANDROID_AVD_HOME:-}" ]; then
            avd_root="${ANDROID_AVD_HOME%/}"
          elif [ -n "${ANDROID_SDK_HOME:-}" ]; then
            avd_root="${ANDROID_SDK_HOME%/}/avd"
          else
            avd_root="${HOME%/}/.android/avd"
          fi

          mkdir -p "$avd_root"
          export ANDROID_AVD_HOME="$avd_root"
          explicit_avd_dir="${avd_root}/${{ matrix.avd }}.avd"

          create_cmd=("$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager" create avd -n ${{ matrix.avd }} -k "system-images;android-${API_LEVEL};${{ matrix.tag }};${ABI}" --force --path "${explicit_avd_dir}")
          if [ -n "${{ matrix.device_id }}" ]; then
            if "$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager" list device | grep -Fq "id: ${{ matrix.device_id }}"; then
              create_cmd+=(--device "${{ matrix.device_id }}")
            else
              echo "Requested device id ${{ matrix.device_id }} not found; proceeding without explicit hardware profile"
            fi
          fi

          if ! printf 'no\n' | "${create_cmd[@]}"; then
            echo "Falling back to default hardware profile for ${{ matrix.avd }}"
            printf 'no\n' | "$ANDROID_HOME/cmdline-tools/latest/bin/avdmanager" create avd -n ${{ matrix.avd }} -k "system-images;android-${API_LEVEL};${{ matrix.tag }};${ABI}" --force --path "${explicit_avd_dir}"
          fi

          config_candidates=()
          config_candidates+=("${explicit_avd_dir%/}/config.ini")
          if [ -n "${ANDROID_AVD_HOME:-}" ]; then
            config_candidates+=("${ANDROID_AVD_HOME%/}/${{ matrix.avd }}.avd/config.ini")
          fi
          if [ -n "${ANDROID_SDK_HOME:-}" ]; then
            config_candidates+=("${ANDROID_SDK_HOME%/}/avd/${{ matrix.avd }}.avd/config.ini")
          fi
          config_candidates+=("$HOME/.android/avd/${{ matrix.avd }}.avd/config.ini")

          avd_path=$("$ANDROID_HOME"/cmdline-tools/latest/bin/avdmanager list avd | awk -v avd="${{ matrix.avd }}" 'BEGIN{RS="";FS="\n"} $0 ~ "Name: " avd {for (i = 1; i <= NF; ++i) if ($i ~ /^Path: /) {sub(/^Path: /, "", $i); print $i; exit}}')
          if [ -n "$avd_path" ]; then
            config_candidates+=("${avd_path%/}/config.ini")
          fi

          config_path=""
          for attempt in $(seq 1 90); do
            for candidate in "${config_candidates[@]}"; do
              if [ -f "$candidate" ]; then
                config_path="$candidate"
                break 2
              fi
            done

            # avdmanager occasionally finishes before the config file is flushed to disk
            # which causes flaky failures on CI runners. Wait a moment and retry.
            sleep 2
          done

          if [ -z "$config_path" ]; then
            echo "AVD configuration not found after waiting 180 seconds. Checked:" >&2
            printf '  - %s\n' "${config_candidates[@]}" >&2
            exit 1
          fi
          if [ -n "${{ matrix.hardware_overrides }}" ]; then
            echo "Applying hardware overrides for ${{ matrix.device_label }}"
            printf '%s\n' "${{ matrix.hardware_overrides }}" >> "$config_path"
          fi

          disk_partition_args=()
          min_partition_mb=8192
          if [ -n "${{ matrix.disk_mb }}" ]; then
            requested_disk_mb=${{ matrix.disk_mb }}
            final_disk_mb=$requested_disk_mb
            available_mb=$(df -Pm "$avd_root" | awk 'NR==2 {print $4}')
            reserve_mb=2048
            partition_overhead_mb=2500

            if [[ "$available_mb" =~ ^[0-9]+$ ]]; then
              if [ "$available_mb" -le $((reserve_mb + partition_overhead_mb)) ]; then
                echo "Only ${available_mb} MB free on $avd_root; cannot allocate userdata partition." >&2
                exit 1
              fi

              safe_max=$((available_mb - reserve_mb - partition_overhead_mb))
              if [ "$safe_max" -le 0 ]; then
                echo "Insufficient disk space after reserving ${reserve_mb} MB and accounting for emulator overhead of ${partition_overhead_mb} MB (available: ${available_mb} MB)." >&2
                exit 1
              fi

              if [ "$safe_max" -lt "$final_disk_mb" ]; then
                final_disk_mb=$safe_max
                echo "Requested data partition size ${requested_disk_mb} MB exceeds available capacity (${available_mb} MB available, reserving ${reserve_mb} MB and emulator overhead ${partition_overhead_mb} MB). Using ${final_disk_mb} MB instead."
              fi
            fi

            if [ "$final_disk_mb" -le 0 ]; then
              echo "Unable to determine a valid userdata partition size (computed ${final_disk_mb} MB)." >&2
              exit 1
            fi

            if [ "$final_disk_mb" -lt "$min_partition_mb" ]; then
              echo "::warning::Computed userdata partition size ${final_disk_mb} MB below minimum ${min_partition_mb} MB; using emulator default sizing instead." >&2
              if grep -q '^disk.dataPartition.size=' "$config_path"; then
                perl -0pi -e 's/^disk\.dataPartition\.size=.*\n//' "$config_path"
              fi
            else
              echo "Configuring ${{ matrix.device_label }} data partition size to ${final_disk_mb} MB"
              if grep -q '^disk.dataPartition.size=' "$config_path"; then
                perl -0pi -e "s/^disk\\.dataPartition\\.size=.*/disk.dataPartition.size=${final_disk_mb}M/" "$config_path"
              else
                printf 'disk.dataPartition.size=%sM\n' "$final_disk_mb" >> "$config_path"
              fi
              disk_partition_args=("-partition-size" "$final_disk_mb")
            fi
          fi

          ensure_config_value() {
            local key="$1"
            local value="$2"
            local escaped_key

            escaped_key=$(printf '%s' "$key" | sed 's/[][\\.^$*+?{}|()]/\\&/g')

            if grep -Eq "^${escaped_key}=" "$config_path"; then
              perl -0pi -e "s/^${escaped_key}=.*/${key}=${value}/" "$config_path"
            else
              printf '%s=%s\n' "$key" "$value" >> "$config_path"
            fi
          }

          if [ "${ACTIONS_RUNNER_DISABLE_NESTED_VIRTUALIZATION:-false}" = "true" ]; then
            ensure_config_value "hw.cpu.nested" "no"
          fi

          accel_args=()
          if [ "${RUNNER_OS:-}" = "macOS" ]; then
            echo "macOS runners do not expose HVF; starting emulator with -no-accel"
            accel_args=("-no-accel" "-accel" "off")
          else
            if [ "${ACTIONS_RUNNER_ACCELERATION_PREFERENCE:-}" = "kvm" ] \
              && "$ANDROID_HOME"/emulator/emulator-check accel 2>&1 | grep -qi 'KVM (version'; then
              echo "KVM acceleration available; enabling hardware acceleration"
              accel_args=("-accel" "on")
            else
              echo "Hardware acceleration unavailable; starting emulator with -no-accel"
              accel_args=("-no-accel" "-accel" "off")
            fi
          fi

          emulator_gpu="${NOVAPDF_EMULATOR_GPU_MODE:-}"
          if [ -n "$emulator_gpu" ]; then
            echo "Using emulator GPU mode override: $emulator_gpu"
          else
            emulator_gpu="${GPU_MODE:-swiftshader_indirect}"
          fi
          if [ -z "$emulator_gpu" ]; then
            emulator_gpu="swiftshader_indirect"
          fi

          emulator_memory="${NOVAPDF_EMULATOR_RAM_MB:-}"
          if [[ "$emulator_memory" =~ ^[0-9]+$ ]]; then
            echo "Using emulator RAM override: ${emulator_memory} MB"
          else
            emulator_memory="${EMULATOR_RAM_MB:-${{ matrix.ram_mb }}}"
          fi
          if ! [[ "$emulator_memory" =~ ^[0-9]+$ ]]; then
            emulator_memory="${{ matrix.ram_mb }}"
          fi

          requested_emulator_memory="$emulator_memory"
          min_emulator_memory_mb=6144
          memory_reserve_mb=2048
          host_total_mb=0
          host_available_mb=0
          if [ -r /proc/meminfo ]; then
            host_total_mb=$(awk '/^MemTotal:/ {print int($2 / 1024)}' /proc/meminfo | tail -n 1)
            host_available_mb=$(awk '/^MemAvailable:/ {print int($2 / 1024)}' /proc/meminfo | tail -n 1)
          fi

          safe_max_memory_mb=""
          if [[ "$host_available_mb" =~ ^[0-9]+$ ]] && [ "$host_available_mb" -gt 0 ]; then
            safe_max_memory_mb=$((host_available_mb - memory_reserve_mb))
          elif [[ "$host_total_mb" =~ ^[0-9]+$ ]] && [ "$host_total_mb" -gt 0 ]; then
            safe_max_memory_mb=$((host_total_mb - memory_reserve_mb))
          fi

          if [[ -n "$safe_max_memory_mb" ]]; then
            if [ "$safe_max_memory_mb" -le 0 ]; then
              echo "::error::Host reported insufficient free memory (${safe_max_memory_mb} MB) after reserving ${memory_reserve_mb} MB for system processes." >&2
              exit 1
            fi
            if [ "$safe_max_memory_mb" -lt "$min_emulator_memory_mb" ]; then
              echo "::error::Host free memory ${safe_max_memory_mb} MB below minimum emulator requirement ${min_emulator_memory_mb} MB." >&2
              exit 1
            fi
            if [ "$emulator_memory" -gt "$safe_max_memory_mb" ]; then
              echo "Requested emulator RAM ${emulator_memory} MB exceeds safe host capacity ${safe_max_memory_mb} MB; using ${safe_max_memory_mb} MB." >&2
              emulator_memory=$safe_max_memory_mb
            fi
          fi

          if [ "$emulator_memory" -lt "$min_emulator_memory_mb" ]; then
            echo "::error::Emulator RAM ${emulator_memory} MB below enforced minimum ${min_emulator_memory_mb} MB." >&2
            exit 1
          fi

          echo "Final emulator RAM configuration: ${emulator_memory} MB (requested ${requested_emulator_memory} MB)"

          ensure_config_value "hw.gpu.mode" "$emulator_gpu"
          if [ "$emulator_gpu" = "off" ]; then
            ensure_config_value "hw.gpu.enabled" "no"
          else
            ensure_config_value "hw.gpu.enabled" "yes"
          fi
          if [[ "$emulator_memory" =~ ^[0-9]+$ ]]; then
            ensure_config_value "hw.ramSize" "$emulator_memory"
          fi

          echo "Host memory snapshot immediately before emulator launch command"
          print_host_memory_stats

          echo "Launching emulator with GPU mode '$emulator_gpu' and ${emulator_memory} MB of RAM"

          $ANDROID_HOME/emulator/emulator -avd ${{ matrix.avd }} -no-snapshot -wipe-data -no-window -gpu "$emulator_gpu" -memory "$emulator_memory" -skin ${{ matrix.skin }} -camera-back none -camera-front none -no-boot-anim "${accel_args[@]}" "${disk_partition_args[@]}" &
          emulator_pid=$!

          echo "Host memory snapshot after scheduling emulator process"
          print_host_memory_stats

          watchdog_log="$RUNNER_TEMP/emulator-watchdog.log"
          echo "EMULATOR_WATCHDOG_LOG=$watchdog_log" >> "$GITHUB_ENV"

          echo "EMULATOR_PID=$emulator_pid" >> "$GITHUB_ENV"
          echo "EMULATOR_SERIAL=emulator-5554" >> "$GITHUB_ENV"

          if [ -x "${GITHUB_WORKSPACE}/tools/emulator_watchdog.sh" ]; then
            nohup "${GITHUB_WORKSPACE}/tools/emulator_watchdog.sh" "$emulator_pid" emulator-5554 900 600 60 >"$watchdog_log" 2>&1 &
            watchdog_pid=$!
            echo "EMULATOR_WATCHDOG_PID=$watchdog_pid" >> "$GITHUB_ENV"
          else
            echo "Watchdog script not found or not executable; skipping watchdog startup" >&2
          fi

          echo "Waiting for emulator PID ${emulator_pid} to reach readiness markers in a subsequent step"
      - name: Wait for emulator readiness
        run: |
          set -euo pipefail
          serial="${EMULATOR_SERIAL:-emulator-5554}"
          timeout="${NOVAPDF_EMULATOR_READY_TIMEOUT:-900}"

          if ! [[ "$timeout" =~ ^[0-9]+$ ]]; then
            echo "Invalid readiness timeout '${timeout}', defaulting to 900 seconds" >&2
            timeout=900
          fi

          echo "Waiting up to ${timeout} seconds for emulator ${serial} readiness"
          if ! tools/wait_for_emulator_readiness.sh --serial "$serial" --timeout "$timeout"; then
            echo "::error::Emulator ${serial} did not reach readiness within ${timeout} seconds" >&2
            exit 1
          fi
      - name: Capture emulator memory after boot
        run: |
          set -euo pipefail
          serial="${EMULATOR_SERIAL:-emulator-5554}"
          resource_dir="${ARTIFACTS_DIR}/resources/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$resource_dir"
          python3 tools/device_resource_snapshot.py \
            --label "boot-complete" \
            --include-properties \
            --serial "$serial" \
            --output "${resource_dir}/boot-complete.json"
      - name: Configure emulator system settings
        run: |
          set -euo pipefail
          serial="${EMULATOR_SERIAL:-emulator-5554}"

          adb -s "$serial" wait-for-device
          adb -s "$serial" shell settings put global window_animation_scale 0 || true
          adb -s "$serial" shell settings put global transition_animation_scale 0 || true
          adb -s "$serial" shell settings put global animator_duration_scale 0 || true
          adb -s "$serial" shell input keyevent 82 || true
      - name: Install app under test
        run: |
          set -euo pipefail

          wait_for_property() {
            local property="$1"
            local expected="$2"
            local label="$3"
            local deadline="$4"
            local interval=5
            local elapsed=0
            local value=""
            local expected_display="${expected//|/, }"

            IFS='|' read -r -a expected_values <<< "$expected"

            while true; do
              if value=$(adb shell getprop "$property" 2>/dev/null); then
                value=$(printf '%s' "$value" | tr -d '\r' | tr -d '\n')
                for candidate in "${expected_values[@]}"; do
                  if [ "$value" = "$candidate" ]; then
                    return 0
                  fi
                done
              fi

              if [ $elapsed -ge $deadline ]; then
                local last_value="$value"
                if [ -z "$last_value" ]; then
                  last_value="<unset>"
                fi
                echo "${label} did not report an accepted value (${expected_display}) within $((deadline / 60)) minutes (last value: ${last_value})" >&2
                exit 1
              fi

              sleep $interval
              elapsed=$((elapsed + interval))
            done
          }

          wait_for_settings_value() {
            local namespace="$1"
            local key="$2"
            local expected="$3"
            local label="$4"
            local deadline="$5"
            local interval=5
            local elapsed=0
            local value=""
            local expected_display="${expected//|/, }"

            IFS='|' read -r -a expected_values <<< "$expected"

            while true; do
              if value=$(adb shell settings get "$namespace" "$key" 2>/dev/null); then
                value=$(printf '%s' "$value" | tr -d '\r' | tr -d '\n')
                for candidate in "${expected_values[@]}"; do
                  if [ "$value" = "$candidate" ]; then
                    return 0
                  fi
                done
              fi

              if [ $elapsed -ge $deadline ]; then
                local last_value="$value"
                if [ -z "$last_value" ]; then
                  last_value="<unset>"
                fi
                echo "${label} did not reach an accepted value (${expected_display}) within $((deadline / 60)) minutes (last value: ${last_value})" >&2
                exit 1
              fi

              sleep $interval
              elapsed=$((elapsed + interval))
            done
          }

          wait_for_service() {
            local service="$1"
            local label="$2"
            local deadline="$3"
            local interval=5
            local elapsed=0
            local status=""

            while true; do
              if status=$(adb shell service check "$service" 2>/dev/null); then
                status=$(printf '%s' "$status" | tr -d '\r' | tr -d '\n')
                if printf '%s' "$status" | grep -qE ': found$'; then
                  return 0
                fi
              fi

              if [ $elapsed -ge $deadline ]; then
                echo "${label} service did not become available within $((deadline / 60)) minutes" >&2
                exit 1
              fi

              sleep $interval
              elapsed=$((elapsed + interval))
            done
          }

          wait_for_content_provider() {
            local uri="$1"
            local label="$2"
            local deadline="$3"
            local interval=5
            local elapsed=0

            while true; do
              if adb shell content query --uri "$uri" --user 0 --limit 1 >/dev/null 2>&1; then
                return 0
              fi

              if [ $elapsed -ge $deadline ]; then
                echo "${label} content provider did not become available within $((deadline / 60)) minutes" >&2
                exit 1
              fi

              sleep $interval
              elapsed=$((elapsed + interval))
            done
          }


          wait_for_storage_volumes() {
            local deadline="$1"
            local interval=5
            local elapsed=0

            while true; do
              if adb shell sm list-volumes all >/dev/null 2>&1; then
                return 0
              fi

              if [ $elapsed -ge $deadline ]; then
                echo "Storage manager volumes did not become accessible within $((deadline / 60)) minutes" >&2
                exit 1
              fi

              sleep $interval
              elapsed=$((elapsed + interval))
            done
          }

          wait_for_service_registration() {
            local label="$1"
            local deadline="$2"
            local interval=5
            local elapsed=0
            local status=""

            while true; do
              if status=$(adb shell service check package 2>/dev/null); then
                status=$(printf '%s' "$status" | tr -d '\r' | tr -d '\n')
                if printf '%s' "$status" | grep -qE ': found$'; then
                  return 0
                fi
              fi

              if [ $elapsed -ge $deadline ]; then
                echo "${label} service binder did not become available within $((deadline / 60)) minutes" >&2
                exit 1
              fi

              sleep $interval
              elapsed=$((elapsed + interval))
            done
          }

          resolve_apk_path() {
            local variant_dir="$1"
            local fallback="$2"
            local metadata="${variant_dir}/output-metadata.json"

            if [ -f "$metadata" ]; then
              local resolved_path
              local python_script
              python_script=$'import json\nimport os\nimport sys\n\nvariant_dir = sys.argv[1]\nmetadata_path = os.path.join(variant_dir, "output-metadata.json")\n\npreferred_abis = ["", "x86_64", "arm64-v8a"]\ncandidates = []\n\ntry:\n    with open(metadata_path, "r", encoding="utf-8") as fh:\n        data = json.load(fh)\nexcept Exception:\n    data = None\n\nif data:\n    for element in data.get("elements", []):\n        output_file = element.get("outputFile")\n        if not output_file:\n            continue\n        path = os.path.join(variant_dir, output_file)\n        if not os.path.isfile(path):\n            continue\n        filters = element.get("filters") or []\n        abi = ""\n        for flt in filters:\n            if flt.get("filterType") == "ABI":\n                abi = (flt.get("value") or "").strip()\n                break\n        candidates.append((abi, path))\n\nif candidates:\n    def sort_key(item):\n        abi, path = item\n        try:\n            abi_index = preferred_abis.index(abi)\n        except ValueError:\n            abi_index = len(preferred_abis)\n        return (abi_index, path)\n\n    best = min(candidates, key=sort_key)\n    sys.stdout.write(best[1])\n'
              resolved_path=$(python3 - "$variant_dir" -c "$python_script")
              resolved_path=$(printf '%s' "$resolved_path" | tr -d '\r\n')
              if [ -n "$resolved_path" ]; then
                printf '%s' "$resolved_path"
                return 0
              fi
            fi

            printf '%s' "$fallback"
          }

          adb_install_with_fallback() {
            local apk_path="$1"
            shift || true

            local allow_test_apk=false
            while [ $# -gt 0 ]; do
              case "$1" in
                --allow-test)
                  allow_test_apk=true
                  ;;
              esac
              shift || true
            done

            local install_args=(-r)
            if [ "$allow_test_apk" = true ]; then
              install_args+=(-t)
            fi

            if adb install "${install_args[@]}" "$apk_path"; then
              return 0
            fi

            local exit_code=$?
            echo "Streaming adb install failed with exit code $exit_code; retrying with --no-streaming" >&2

            if adb install --no-streaming "${install_args[@]}" "$apk_path"; then
              return 0
            fi

            local fallback_exit_code=$?
            return $fallback_exit_code
          }

          apk_path="$(resolve_apk_path "app/build/outputs/apk/debug" "app/build/outputs/apk/debug/app-debug.apk")"
          printf 'Resolved debug APK path to %s\n' "$apk_path"

          if [ ! -f "$apk_path" ]; then
            echo "Debug APK not found at $apk_path; assembling it now"
            ./gradlew :app:assembleDebug --stacktrace --no-build-cache
            apk_path="$(resolve_apk_path "app/build/outputs/apk/debug" "app/build/outputs/apk/debug/app-debug.apk")"
            printf 'Resolved debug APK path to %s after assemble\n' "$apk_path"
          fi

          if [ ! -f "$apk_path" ]; then
            echo "::error::Debug APK is still missing at $apk_path after assembly"
            exit 1
          fi

          echo "Waiting for emulator to report as online"
          adb wait-for-device

          boot_deadline=$((5 * 60))
          boot_elapsed=0
          until adb shell getprop sys.boot_completed 2>/dev/null | tr -d '\r' | grep -q '^1$'; do
            sleep 5
            boot_elapsed=$((boot_elapsed + 5))
            if [ $boot_elapsed -ge $boot_deadline ]; then
              echo "Emulator failed to report boot completion within $((boot_deadline / 60)) minutes" >&2
              exit 1
            fi
          done

          echo "Waiting for package manager command interface to become available"
          pm_deadline=$((5 * 60))
          pm_elapsed=0
          until adb shell cmd package list packages >/dev/null 2>&1; do
            sleep 5
            pm_elapsed=$((pm_elapsed + 5))
            if [ $pm_elapsed -ge $pm_deadline ]; then
              echo "Package manager service did not become available within $((pm_deadline / 60)) minutes" >&2
              exit 1
            fi
          done

          echo "Waiting for credential encrypted storage to become available"
          wait_for_property "sys.user.0.ce_available" "1|true" "Credential encrypted storage" $((5 * 60))

          echo "Waiting for settings provider readiness"
          wait_for_settings_value global device_provisioned "1|true" "device provisioning" $((5 * 60))
          wait_for_settings_value secure user_setup_complete "1|true" "user setup" $((5 * 60))
          wait_for_content_provider "content://settings/global" "Settings" $((5 * 60))

          echo "Waiting for package manager binder registration"
          wait_for_service_registration "Package manager" $((5 * 60))

          echo "Waiting for StorageManager service availability"
          wait_for_service "mount" "StorageManager" $((5 * 60))
          wait_for_storage_volumes $((5 * 60))

          echo "Installing $apk_path onto the emulator"
          install_attempt=1
          install_attempts_max=3

          while true; do
            if adb_install_with_fallback "$apk_path"; then
              break
            fi

            if [ $install_attempt -ge $install_attempts_max ]; then
              echo "Failed to install $apk_path after $install_attempts_max attempts" >&2
              exit 1
            fi

            install_attempt=$((install_attempt + 1))
            echo "adb install failed (attempt $((install_attempt - 1))) — waiting for package manager before retrying"

            retry_deadline=$((2 * 60))
            retry_elapsed=0
            wait_for_service_registration "Package manager" $((2 * 60))

            until adb shell cmd package list packages >/dev/null 2>&1; do
              sleep 5
              retry_elapsed=$((retry_elapsed + 5))
              if [ $retry_elapsed -ge $retry_deadline ]; then
                echo "Package manager did not recover within $((retry_deadline / 60)) minutes after failed install" >&2
                exit 1
              fi
            done

            sleep 5
            echo "Retrying adb install (attempt $install_attempt of $install_attempts_max)"
          done
      - name: Fetch stress PDF fixtures from S3
        if: env.UNIT_TESTS_PASSED == 'true'
        id: fetch_pdfs
        env:
          BUCKET: ${{ secrets.S3_BUCKET_NAME }}
          STRESS_PDF_KEY: ${{ vars.STRESS_PDF_S3_KEY || secrets.STRESS_PDF_S3_KEY }}
          THOUSAND_PDF_KEY: ${{ vars.THOUSAND_PAGE_PDF_S3_KEY || secrets.THOUSAND_PAGE_PDF_S3_KEY }}
          FIXTURE_DIR: ${{ github.workspace }}/instrumentation-fixtures
        run: |
          set -euo pipefail

          if [ -z "${BUCKET:-}" ]; then
            echo "::error::S3 bucket name not provided; ensure S3_BUCKET_NAME secret is set"
            exit 1
          fi

          if [ -z "${STRESS_PDF_KEY:-}" ] || [ -z "${THOUSAND_PDF_KEY:-}" ]; then
            echo "::error::Missing S3 object keys for instrumentation PDF fixtures"
            exit 1
          fi

          mkdir -p "$FIXTURE_DIR"

          download_fixture() {
            local key="$1"
            local label="$2"
            local dest="$FIXTURE_DIR/$(basename "$key")"
            local tmp="${dest}.tmp"
            local metadata_json=""
            local version_id=""
            local metadata_etag=""
            local metadata_size=""
            local metadata_checksum=""

            if ! metadata_json=$(aws s3api head-object --bucket "$BUCKET" --key "$key" --output json); then
              echo "::error::Failed to query metadata for ${label} PDF fixture at s3://${BUCKET}/${key}" >&2
              exit 1
            fi

            readarray -t metadata_fields < <(
              python3 -c '
                import base64
                import json
                import sys

                raw = sys.argv[1] if len(sys.argv) > 1 else ""
                try:
                    data = json.loads(raw)
                except Exception:
                    data = {}

                version = data.get("VersionId") or ""
                etag = (data.get("ETag") or "").strip("\"")
                size = data.get("ContentLength")
                checksum = data.get("ChecksumSHA256") or ""

                if checksum:
                    try:
                        checksum = base64.b64decode(checksum).hex()
                    except Exception:
                        checksum = ""

                print(version)
                print(etag)
                print("" if size is None else size)
                print(checksum)
              ' "$metadata_json"
            )

            if [ "${metadata_fields[0]:-}" != "" ] && [ "${metadata_fields[0]}" != "null" ]; then
              version_id="${metadata_fields[0]}"
            fi

            if [ -n "$version_id" ]; then
              echo "Resolved ${label} fixture version ${version_id} for download" >&2
            else
              echo "Resolved ${label} fixture latest version (bucket not versioned)" >&2
            fi

            if [ "${metadata_fields[1]:-}" != "" ] && [ "${metadata_fields[1]}" != "null" ]; then
              metadata_etag="${metadata_fields[1]}"
              echo "Resolved ${label} fixture ETag ${metadata_etag}" >&2
            fi

            if [ "${metadata_fields[2]:-}" != "" ] && [ "${metadata_fields[2]}" != "null" ]; then
              metadata_size="${metadata_fields[2]}"
              echo "Resolved ${label} fixture size ${metadata_size} bytes" >&2
            fi

            if [ "${metadata_fields[3]:-}" != "" ] && [ "${metadata_fields[3]}" != "null" ]; then
              metadata_checksum="${metadata_fields[3]}"
              echo "Resolved ${label} fixture SHA-256 checksum ${metadata_checksum}" >&2
            fi

            declare -g LAST_DOWNLOADED_VERSION="$version_id"
            declare -g LAST_DOWNLOADED_ETAG="$metadata_etag"
            declare -g LAST_DOWNLOADED_SIZE="$metadata_size"
            declare -g LAST_DOWNLOADED_CHECKSUM="$metadata_checksum"

            local version_args=()
            if [ -n "$version_id" ]; then
              version_args=(--version-id "$version_id")
            fi

            echo "Downloading ${label} fixture from s3://${BUCKET}/${key}" >&2
            if ! aws s3api get-object --bucket "$BUCKET" --key "$key" "${version_args[@]}" "$tmp" >/dev/null; then
              echo "::error::Failed to download ${label} PDF fixture from s3://${BUCKET}/${key}" >&2
              rm -f "$tmp"
              exit 1
            fi

            if [ ! -s "$tmp" ]; then
              echo "::error::Downloaded ${label} PDF fixture is empty or missing: $tmp" >&2
              rm -f "$tmp"
              exit 1
            fi

            if [ -n "$metadata_size" ] && [[ "$metadata_size" =~ ^[0-9]+$ ]]; then
              local actual_size
              actual_size=$(stat -c '%s' "$tmp")
              if [ "$actual_size" -ne "$metadata_size" ]; then
                echo "::error::${label} fixture size mismatch: expected ${metadata_size} bytes, downloaded ${actual_size} bytes" >&2
                rm -f "$tmp"
                exit 1
              fi
            fi

            if [ -n "$metadata_checksum" ]; then
              local actual_checksum
              actual_checksum=$(sha256sum "$tmp" | awk '{print tolower($1)}')
              local normalized_expected
              normalized_expected=$(printf '%s' "$metadata_checksum" | tr 'A-F' 'a-f')
              if [ "$actual_checksum" != "$normalized_expected" ]; then
                echo "::error::${label} fixture checksum mismatch: expected ${normalized_expected}, downloaded ${actual_checksum}" >&2
                rm -f "$tmp"
                exit 1
              fi
            fi

            mv "$tmp" "$dest"
            echo "$dest"
          }

          stress_path=$(download_fixture "$STRESS_PDF_KEY" "stress")
          stress_version="${LAST_DOWNLOADED_VERSION:-}"
          stress_etag="${LAST_DOWNLOADED_ETAG:-}"
          stress_size="${LAST_DOWNLOADED_SIZE:-}"
          stress_checksum="${LAST_DOWNLOADED_CHECKSUM:-}"

          thousand_path=$(download_fixture "$THOUSAND_PDF_KEY" "thousand-page")
          thousand_version="${LAST_DOWNLOADED_VERSION:-}"
          thousand_etag="${LAST_DOWNLOADED_ETAG:-}"
          thousand_size="${LAST_DOWNLOADED_SIZE:-}"
          thousand_checksum="${LAST_DOWNLOADED_CHECKSUM:-}"

          {
            echo "stress_path=${stress_path}"
            echo "thousand_path=${thousand_path}"
            if [ -n "$stress_version" ]; then
              echo "stress_version=${stress_version}"
            fi
            if [ -n "$stress_etag" ]; then
              echo "stress_etag=${stress_etag}"
            fi
            if [ -n "$stress_size" ]; then
              echo "stress_size=${stress_size}"
            fi
            if [ -n "$stress_checksum" ]; then
              echo "stress_checksum=${stress_checksum}"
            fi
            if [ -n "$thousand_version" ]; then
              echo "thousand_version=${thousand_version}"
            fi
            if [ -n "$thousand_etag" ]; then
              echo "thousand_etag=${thousand_etag}"
            fi
            if [ -n "$thousand_size" ]; then
              echo "thousand_size=${thousand_size}"
            fi
            if [ -n "$thousand_checksum" ]; then
              echo "thousand_checksum=${thousand_checksum}"
            fi
          } >> "$GITHUB_OUTPUT"

          manifest_dir="${ARTIFACTS_DIR}/fixtures/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$manifest_dir"

          export MANIFEST_PATH="${manifest_dir}/pdf-fixtures.json"
          export STRESS_PATH="$stress_path"
          export STRESS_VERSION="$stress_version"
          export STRESS_ETAG="$stress_etag"
          export STRESS_SIZE="$stress_size"
          export STRESS_CHECKSUM="$stress_checksum"
          export THOUSAND_PATH="$thousand_path"
          export THOUSAND_VERSION="$thousand_version"
          export THOUSAND_ETAG="$thousand_etag"
          export THOUSAND_SIZE="$thousand_size"
          export THOUSAND_CHECKSUM="$thousand_checksum"

          python3 - <<'PY'
          import json
          import os
          import pathlib

          manifest_path = pathlib.Path(os.environ["MANIFEST_PATH"])

          def _load_existing(path: pathlib.Path) -> dict:
              if not path.exists():
                  return {}
              try:
                  return json.loads(path.read_text(encoding="utf-8"))
              except Exception:
                  return {}

          data = _load_existing(manifest_path)

          data["stress"] = {
              "path": os.environ.get("STRESS_PATH", ""),
              "version": os.environ.get("STRESS_VERSION", ""),
              "etag": os.environ.get("STRESS_ETAG", ""),
              "size": os.environ.get("STRESS_SIZE", ""),
              "sha256": os.environ.get("STRESS_CHECKSUM", ""),
          }

          data["thousand_page"] = {
              "path": os.environ.get("THOUSAND_PATH", ""),
              "version": os.environ.get("THOUSAND_VERSION", ""),
              "etag": os.environ.get("THOUSAND_ETAG", ""),
              "size": os.environ.get("THOUSAND_SIZE", ""),
              "sha256": os.environ.get("THOUSAND_CHECKSUM", ""),
          }

          manifest_path.write_text(json.dumps(data, indent=2, sort_keys=True), encoding="utf-8")
          PY
      - name: Download AI.pdf fixture from S3
        if: env.UNIT_TESTS_PASSED == 'true'
        id: download_ai_pdf
        env:
          AI_PDF_BUCKET: ${{ vars.AI_PDF_BUCKET || 'pics-1234' }}
          AI_PDF_KEY: ${{ vars.AI_PDF_KEY || 'AI.pdf' }}
          AI_PDF_SHA256: ${{ vars.AI_PDF_SHA256 || secrets.AI_PDF_SHA256 }}
          AI_PDF_SIZE: ${{ vars.AI_PDF_SIZE || secrets.AI_PDF_SIZE }}
          FIXTURE_DIR: ${{ github.workspace }}/instrumentation-fixtures
        run: |
          set -euo pipefail

          bucket="${AI_PDF_BUCKET:-}"
          key="${AI_PDF_KEY:-}"
          expected_sha="${AI_PDF_SHA256:-}"
          expected_size="${AI_PDF_SIZE:-}"

          if [ -z "$bucket" ] || [ -z "$key" ]; then
            echo "::error::AI.pdf bucket or key is empty. Set AI_PDF_BUCKET and AI_PDF_KEY repository variables if the defaults are incorrect."
            exit 1
          fi

          metadata_json=""
          if ! metadata_json=$(aws s3api head-object --bucket "$bucket" --key "$key" --output json); then
            echo "::error::Unable to query metadata for AI.pdf at s3://${bucket}/${key}" >&2
            exit 1
          fi

          readarray -t metadata_fields < <(
            python3 -c $'import base64, json, sys\ntry:\n    data = json.load(sys.stdin)\nexcept Exception:\n    data = {}\nsize = data.get("ContentLength")\nchecksum = (data.get("ChecksumSHA256") or "")\netag = (data.get("ETag") or "").strip(\'"\')\nversion_id = data.get("VersionId") or ""\nif checksum:\n    try:\n        checksum = base64.b64decode(checksum).hex()\n    except Exception:\n        checksum = ""\nprint("" if size is None else size)\nprint(checksum)\nprint(etag)\nprint(version_id)' <<< "$metadata_json"
          )

          if [ -z "$expected_size" ] && [ -n "${metadata_fields[0]:-}" ]; then
            echo "::notice::Using AI.pdf size ${metadata_fields[0]} bytes from S3 metadata as the expected value."
            expected_size="${metadata_fields[0]}"
          fi
          if [ -z "$expected_sha" ] && [ -n "${metadata_fields[1]:-}" ]; then
            echo "::notice::Using AI.pdf checksum derived from S3 metadata as the expected value."
            expected_sha="${metadata_fields[1]}"
          fi

          ai_pdf_etag="${metadata_fields[2]:-}"
          ai_pdf_version="${metadata_fields[3]:-}"

          if [ -n "$ai_pdf_version" ] && [ "$ai_pdf_version" != "null" ]; then
            echo "Resolved AI.pdf version ${ai_pdf_version}" >&2
          else
            ai_pdf_version=""
            echo "Resolved AI.pdf latest version (bucket not versioned)" >&2
          fi

          if [ -n "$ai_pdf_etag" ] && [ "$ai_pdf_etag" != "null" ]; then
            echo "Resolved AI.pdf ETag ${ai_pdf_etag}" >&2
          fi

          mkdir -p "$FIXTURE_DIR"

          dest="$FIXTURE_DIR/AI.pdf"
          tmp="${dest}.tmp"
          trap 'rm -f "$tmp"' EXIT

          echo "Downloading AI.pdf fixture from s3://${bucket}/${key}" >&2
          version_args=()
          if [ -n "$ai_pdf_version" ]; then
            version_args=(--version-id "$ai_pdf_version")
          fi

          if ! aws s3api get-object --bucket "$bucket" --key "$key" "${version_args[@]}" "$tmp" >/dev/null; then
            echo "::error::Failed to download AI.pdf fixture from s3://${bucket}/${key}" >&2
            exit 1
          fi

          if [ ! -s "$tmp" ]; then
            echo "::error::Downloaded AI.pdf fixture is empty: $tmp" >&2
            exit 1
          fi

          normalized_expected_sha=""
          if [ -n "$expected_sha" ]; then
            normalized_expected_sha=$(printf '%s' "$expected_sha" | tr '[:upper:]' '[:lower:]')
          fi

          actual_size=$(stat -c%s "$tmp")
          if [ -z "$expected_size" ]; then
            echo "::notice::AI.pdf size not supplied; using downloaded size ${actual_size} bytes."
            expected_size="$actual_size"
          elif [ "$actual_size" -ne "$expected_size" ]; then
            echo "::error::AI.pdf size mismatch. Expected ${expected_size} bytes but found ${actual_size} bytes." >&2
            exit 1
          fi

          actual_sha=$(sha256sum "$tmp" | awk '{print $1}')
          if [ -z "$normalized_expected_sha" ]; then
            echo "::notice::AI.pdf checksum not supplied; using downloaded checksum ${actual_sha}."
            normalized_expected_sha="$actual_sha"
          elif [ "$actual_sha" != "$normalized_expected_sha" ]; then
            echo "::error::AI.pdf SHA-256 mismatch. Expected ${normalized_expected_sha} but found ${actual_sha}." >&2
            exit 1
          fi

          mv "$tmp" "$dest"
          trap - EXIT
          rm -f "$tmp"

          echo "ai_pdf_path=${dest}" >> "$GITHUB_OUTPUT"
          if [ -n "$expected_size" ]; then
            echo "ai_pdf_size=$expected_size" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$normalized_expected_sha" ]; then
            echo "ai_pdf_sha256=$normalized_expected_sha" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$ai_pdf_version" ]; then
            echo "ai_pdf_version=$ai_pdf_version" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$ai_pdf_etag" ]; then
            echo "ai_pdf_etag=$ai_pdf_etag" >> "$GITHUB_OUTPUT"
          fi
          manifest_dir="${ARTIFACTS_DIR}/fixtures/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$manifest_dir"

          export MANIFEST_PATH="${manifest_dir}/pdf-fixtures.json"
          export AI_PATH="$dest"
          export AI_VERSION="$ai_pdf_version"
          export AI_ETAG="$ai_pdf_etag"
          export AI_SIZE="$expected_size"
          export AI_SHA="$normalized_expected_sha"

          python3 - <<'PY'
          import json
          import os
          import pathlib

          manifest_path = pathlib.Path(os.environ["MANIFEST_PATH"])

          def _load_existing(path: pathlib.Path) -> dict:
              if not path.exists():
                  return {}
              try:
                  return json.loads(path.read_text(encoding="utf-8"))
              except Exception:
                  return {}

          data = _load_existing(manifest_path)

          data["ai_pdf"] = {
              "path": os.environ.get("AI_PATH", ""),
              "version": os.environ.get("AI_VERSION", ""),
              "etag": os.environ.get("AI_ETAG", ""),
              "size": os.environ.get("AI_SIZE", ""),
              "sha256": os.environ.get("AI_SHA", ""),
          }

          manifest_path.write_text(json.dumps(data, indent=2, sort_keys=True), encoding="utf-8")
          PY
      - name: Stage stress PDFs on emulator
        if: env.UNIT_TESTS_PASSED == 'true'
        env:
          STRESS_DEST: stress-large.pdf
          THOUSAND_DEST: stress-thousand-pages.pdf
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail

          stress_path="${{ steps.fetch_pdfs.outputs.stress_path }}"
          thousand_path="${{ steps.fetch_pdfs.outputs.thousand_path }}"

          if [ -z "$stress_path" ] || [ -z "$thousand_path" ]; then
            echo "::error::Missing downloaded PDF fixture paths"
            exit 1
          fi

          if [ ! -s "$stress_path" ] || [ ! -s "$thousand_path" ]; then
            echo "::error::Downloaded PDF fixtures are missing or empty"
            exit 1
          fi

          adb wait-for-device

          if ! app_data_dir_output=$(adb shell run-as "$PACKAGE_NAME" sh -c 'pwd' 2>&1); then
            echo "::warning::Unable to resolve application data directory via run-as: ${app_data_dir_output}" >&2
            echo "::warning::Skipping PDF fixture staging; instrumentation will generate fixtures on-device" >&2
            exit 0
          fi

          app_data_dir=$(printf '%s' "$app_data_dir_output" | tr -d '\r' | tr -d '\n')
          if [ -z "$app_data_dir" ]; then
            echo "::warning::Application data directory is empty; skipping PDF fixture staging" >&2
            echo "::warning::Instrumentation will generate fixtures on-device" >&2
            exit 0
          fi

          echo "Application data directory resolved to $app_data_dir"

          stage_fixture() {
            local src="$1"
            local dest_name="$2"

            local cache_dir="${app_data_dir}/cache"
            local cache_path="${cache_dir}/${dest_name}"

            local staged_path=""

            if adb shell run-as "$PACKAGE_NAME" sh -c "set -e; mkdir -p \"${cache_dir}\"; cat > \"${cache_path}\"" < "$src"; then
              staged_path="$cache_path"
            else
              echo "::warning::Failed to write ${dest_name} into cache; attempting files directory fallback" >&2

              local files_dir="${app_data_dir}/files"
              local files_path="${files_dir}/${dest_name}"

              if adb shell run-as "$PACKAGE_NAME" sh -c "set -e; mkdir -p \"${files_dir}\"; cat > \"${files_path}\"" < "$src"; then
                staged_path="$files_path"
              else
                echo "::warning::Failed to stream ${dest_name} into application internal storage; instrumentation will generate it on-device" >&2
                return 0
              fi
            fi

            if [ -n "$staged_path" ] && ! adb shell run-as "$PACKAGE_NAME" sh -c "[ -s \"${staged_path}\" ]"; then
              echo "::warning::Staged ${dest_name} is missing or empty after transfer; instrumentation will regenerate it on-device" >&2
            fi
          }

          stage_fixture "$stress_path" "$STRESS_DEST"
          stage_fixture "$thousand_path" "$THOUSAND_DEST"
      - name: Push AI.pdf fixture to device Downloads directory
        if: env.UNIT_TESTS_PASSED == 'true'
        env:
          AI_PDF_PATH: ${{ steps.download_ai_pdf.outputs.ai_pdf_path }}
        run: |
          set -euo pipefail

          ai_pdf_path="${AI_PDF_PATH:-}"

          if [ -z "$ai_pdf_path" ]; then
            echo "::error::AI.pdf path not provided from download step."
            exit 1
          fi

          if [ ! -s "$ai_pdf_path" ]; then
            echo "::error::AI.pdf fixture is missing or empty at ${ai_pdf_path}" >&2
            exit 1
          fi

          adb wait-for-device

          if ! adb shell 'mkdir -p /sdcard/Download'; then
            echo "::warning::Unable to create /sdcard/Download on device; attempting alternate targets" >&2
          fi

          push_targets=(
            "/sdcard/Download/AI.pdf"
            "/storage/emulated/0/Download/AI.pdf"
          )
          pushed_path=""

          for target in "${push_targets[@]}"; do
            echo "Pushing AI.pdf to ${target}" >&2
            if adb push "$ai_pdf_path" "$target"; then
              pushed_path="$target"
              break
            fi
            echo "::warning::Failed to push AI.pdf to ${target}; trying next location" >&2
          done

          if [ -z "$pushed_path" ]; then
            fallback_dir="/data/local/tmp"
            fallback_path="${fallback_dir}/AI.pdf"
            echo "Attempting fallback push of AI.pdf to ${fallback_path}" >&2
            if adb push "$ai_pdf_path" "$fallback_path"; then
              pushed_path="$fallback_path"
              echo "::warning::AI.pdf pushed to fallback location ${fallback_path}; Downloads directory unavailable" >&2
            fi
          fi

          if [ -z "$pushed_path" ]; then
            echo "::error::Failed to push AI.pdf fixture to any known device location" >&2
            exit 1
          fi

          echo "Verifying AI.pdf presence on device at ${pushed_path}" >&2
          adb shell ls -l "$pushed_path"
      - name: Run instrumentation tests against stress PDFs
        if: env.UNIT_TESTS_PASSED == 'true'
        run: |
          set -euo pipefail

          resource_dir="${ARTIFACTS_DIR}/resources/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$resource_dir"

          python3 tools/device_resource_snapshot.py \
            --label "connected-android-test-before" \
            --include-properties \
            --output "${resource_dir}/connected-android-test-before.json"

          adb logcat -c || true
          ./gradlew connectedAndroidTest --stacktrace --rerun-tasks --no-build-cache

          python3 tools/device_resource_snapshot.py \
            --label "connected-android-test-after" \
            --output "${resource_dir}/connected-android-test-after.json"
      - name: Verify heavy PDF instrumentation coverage
        if: env.UNIT_TESTS_PASSED == 'true'
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import pathlib
          import sys
          import xml.etree.ElementTree as ET

          outputs_root = pathlib.Path("app/build/outputs")
          if not outputs_root.exists():
              print("::error::Gradle outputs directory app/build/outputs not found")
              sys.exit(1)

          candidate_roots = [
              outputs_root / "androidTest-results" / "connected",
              outputs_root / "androidTest-results",
              outputs_root / "androidTestResults",
              outputs_root / "connected_android_test_additional_output",
          ]

          search_roots = [root for root in candidate_roots if root.exists()]
          if not search_roots:
              search_roots = [outputs_root]

          def is_instrumentation_report(path: pathlib.Path) -> bool:
              lowered_parts = [part.lower() for part in path.parts]
              return any("androidtest" in part for part in lowered_parts) or "connected" in lowered_parts

          report_paths = sorted(
              {
                  report
                  for root in search_roots
                  for report in root.rglob("TEST-*.xml")
                  if is_instrumentation_report(report)
              }
          )

          if not report_paths:
              print(
                  "::error::Connected Android tests did not generate any instrumentation XML reports under app/build/outputs"
              )
              sys.exit(1)

          required_tests = {
              (
                  "com.novapdf.reader.LargePdfInstrumentedTest",
                  "openLargeAndUnusualDocumentWithoutAnrOrCrash",
              ),
              (
                  "com.novapdf.reader.PdfViewerUiAutomatorTest",
                  "loadsThousandPageDocumentAndActivatesAdaptiveFlow",
              ),
          }

          executed_tests = {}

          for report in report_paths:
              try:
                  tree = ET.parse(report)
              except ET.ParseError as exc:
                  print(f"Skipping unreadable instrumentation report {report}: {exc}")
                  continue

              root = tree.getroot()
              for testcase in root.iter("testcase"):
                  key = (testcase.get("classname"), testcase.get("name"))
                  if key not in required_tests:
                      continue

                  if any(child.tag in {"failure", "error"} for child in testcase):
                      print(
                          f"::error::Required instrumentation test {key[0]}.{key[1]} failed in {report}"
                      )
                      sys.exit(1)

                  if any(child.tag == "skipped" for child in testcase) or testcase.get("status") == "skipped":
                      print(
                          f"::error::Required instrumentation test {key[0]}.{key[1]} was skipped in {report}"
                      )
                      sys.exit(1)

                  executed_tests.setdefault(key, report)

          missing = required_tests.difference(executed_tests.keys())
          if missing:
              missing_descriptions = ", ".join(f"{cls}.{name}" for cls, name in sorted(missing))
              print(
                  f"::error::Connected Android tests did not execute required instrumentation coverage for: {missing_descriptions}"
              )
              sys.exit(1)

          for key, report in sorted(executed_tests.items()):
              print(f"Confirmed {key[0]}.{key[1]} execution in {report}")
          PY
      - name: Collect and validate device logs after connected tests
        if: ${{ env.UNIT_TESTS_PASSED == 'true' && always() }}
        env:
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail
          logs_dir="device-logs/connected-android-test"
          mkdir -p "$logs_dir"
          logcat_path="${logs_dir}/logcat.txt"
          bugreport_path="${logs_dir}/bugreport.zip"
          adb logcat -d > "$logcat_path"
          bugreport_args=()
          if timeout 5m adb bugreport "$bugreport_path"; then
            bugreport_args+=("$bugreport_path")
          else
            echo "::warning::Failed to capture bugreport after connectedAndroidTest; continuing with logcat only" >&2
          fi
          native_dir="${logs_dir}/native-crash"
          if ! tools/collect_native_crash_artifacts.sh "$native_dir"; then
            echo "::warning::Failed to collect native crash artifacts snapshot" >&2
          fi
          if python3 tools/check_logcat_for_crashes.py "$logcat_path" "${bugreport_args[@]}" --package "$PACKAGE_NAME"; then
            echo "Device logs cleared crash and ANR checks" >&2
          else
            echo "::error::Crash signatures detected in device logs; collecting native diagnostics" >&2
            exit 1
          fi
      - name: Run macrobenchmark regression suite
        if: env.UNIT_TESTS_PASSED == 'true' && matrix.device_label == env.BASELINE_DEVICE_LABEL
        run: |
          set -euo pipefail

          resource_dir="${ARTIFACTS_DIR}/resources/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$resource_dir"

          python3 tools/device_resource_snapshot.py \
            --label "macrobenchmark-before" \
            --include-properties \
            --output "${resource_dir}/macrobenchmark-before.json"

          adb logcat -c || true
          ./gradlew :baselineprofile:connectedBenchmarkAndroidTest --stacktrace --no-build-cache

          python3 tools/device_resource_snapshot.py \
            --label "macrobenchmark-after" \
            --output "${resource_dir}/macrobenchmark-after.json"
      - name: Verify macrobenchmark coverage
        if: env.UNIT_TESTS_PASSED == 'true' && matrix.device_label == env.BASELINE_DEVICE_LABEL
        run: |
          set -euo pipefail
          python3 tools/verify_macrobenchmark_coverage.py
      - name: Collect and validate device logs after macrobenchmarks
        if: ${{ env.UNIT_TESTS_PASSED == 'true' && matrix.device_label == env.BASELINE_DEVICE_LABEL && always() }}
        env:
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail
          logs_dir="device-logs/macrobenchmark"
          mkdir -p "$logs_dir"
          logcat_path="${logs_dir}/logcat.txt"
          bugreport_path="${logs_dir}/bugreport.zip"
          adb logcat -d > "$logcat_path"
          bugreport_args=()
          if timeout 5m adb bugreport "$bugreport_path"; then
            bugreport_args+=("$bugreport_path")
          else
            echo "::warning::Failed to capture bugreport after macrobenchmark run; continuing with logcat only" >&2
          fi
          native_dir="${logs_dir}/native-crash"
          if ! tools/collect_native_crash_artifacts.sh "$native_dir"; then
            echo "::warning::Failed to collect native crash artifacts snapshot" >&2
          fi
          if python3 tools/check_logcat_for_crashes.py "$logcat_path" "${bugreport_args[@]}" --package "$PACKAGE_NAME"; then
            echo "Device logs cleared crash and ANR checks" >&2
          else
            echo "::error::Crash signatures detected in device logs; collecting native diagnostics" >&2
            exit 1
          fi
      - name: Generate release baseline profile
        if: env.UNIT_TESTS_PASSED == 'true' && matrix.device_label == env.BASELINE_DEVICE_LABEL
        run: |
          set -euo pipefail

          resource_dir="${ARTIFACTS_DIR}/resources/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$resource_dir"

          python3 tools/device_resource_snapshot.py \
            --label "baseline-profile-before" \
            --include-properties \
            --output "${resource_dir}/baseline-profile-before.json"

          adb logcat -c || true
          ./gradlew :app:generateReleaseBaselineProfile --stacktrace --no-build-cache

          python3 tools/device_resource_snapshot.py \
            --label "baseline-profile-after" \
            --output "${resource_dir}/baseline-profile-after.json"
      - name: Collect and validate device logs after baseline profile generation
        if: ${{ env.UNIT_TESTS_PASSED == 'true' && matrix.device_label == env.BASELINE_DEVICE_LABEL && always() }}
        env:
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail
          logs_dir="device-logs/baseline-profile"
          mkdir -p "$logs_dir"
          logcat_path="${logs_dir}/logcat.txt"
          bugreport_path="${logs_dir}/bugreport.zip"
          adb logcat -d > "$logcat_path"
          bugreport_args=()
          if timeout 5m adb bugreport "$bugreport_path"; then
            bugreport_args+=("$bugreport_path")
          else
            echo "::warning::Failed to capture bugreport after baseline profile generation; continuing with logcat only" >&2
          fi
          native_dir="${logs_dir}/native-crash"
          if ! tools/collect_native_crash_artifacts.sh "$native_dir"; then
            echo "::warning::Failed to collect native crash artifacts snapshot" >&2
          fi
          if python3 tools/check_logcat_for_crashes.py "$logcat_path" "${bugreport_args[@]}" --package "$PACKAGE_NAME"; then
            echo "Device logs cleared crash and ANR checks" >&2
          else
            echo "::error::Crash signatures detected in device logs; collecting native diagnostics" >&2
            exit 1
          fi
      - name: Verify committed baseline profile is current
        if: env.UNIT_TESTS_PASSED == 'true' && matrix.device_label == env.BASELINE_DEVICE_LABEL
        run: |
          set -euo pipefail
          patterns=(
            '*/release/*'
            '*/nonMinifiedRelease/*'
            '*/benchmarkRelease/*'
            '*/benchmark/*'
          )

          generated=""
          for pattern in "${patterns[@]}"; do
            candidate=$(find app/build -type f -iname 'baseline-prof.txt' -path "$pattern" -print -quit)
            if [ -n "$candidate" ]; then
              generated="$candidate"
              break
            fi
          done

          if [ -z "$generated" ]; then
            echo "::error::Failed to locate generated baseline profile under app/build" >&2
            find app/build -maxdepth 4 -type d -print >&2 || true
            exit 1
          fi
          echo "Generated baseline profile located at $generated"
          if ! git --no-pager diff --no-index --color=always -- app/src/main/baseline-prof.txt "$generated"; then
            echo "::error::Generated baseline profile does not match the committed snapshot. Run ./gradlew :app:generateReleaseBaselineProfile and commit app/src/main/baseline-prof.txt" >&2
            exit 1
          fi
      - name: Install debug build for screenshots
        if: env.UNIT_TESTS_PASSED == 'true'
        run: |
          set -euo pipefail

          adb_install_with_fallback_screenshots() {
            local apk_path="$1"

            if adb install -r "$apk_path"; then
              return 0
            fi

            local exit_code=$?
            echo "Streaming adb install failed with exit code $exit_code; retrying with --no-streaming" >&2

            if adb install --no-streaming -r "$apk_path"; then
              return 0
            fi

            local fallback_exit_code=$?
            return $fallback_exit_code
          }

          resolve_apk_path() {
            local variant_dir="$1"
            local fallback="$2"
            local metadata="${variant_dir}/output-metadata.json"

            if [ -f "$metadata" ]; then
              local resolved_path
              local python_script
              python_script=$'import json\nimport os\nimport sys\n\nvariant_dir = sys.argv[1]\nmetadata_path = os.path.join(variant_dir, "output-metadata.json")\n\npreferred_abis = ["", "x86_64", "arm64-v8a"]\ncandidates = []\n\ntry:\n    with open(metadata_path, "r", encoding="utf-8") as fh:\n        data = json.load(fh)\nexcept Exception:\n    data = None\n\nif data:\n    for element in data.get("elements", []):\n        output_file = element.get("outputFile")\n        if not output_file:\n            continue\n        path = os.path.join(variant_dir, output_file)\n        if not os.path.isfile(path):\n            continue\n        filters = element.get("filters") or []\n        abi = ""\n        for flt in filters:\n            if flt.get("filterType") == "ABI":\n                abi = (flt.get("value") or "").strip()\n                break\n        candidates.append((abi, path))\n\nif candidates:\n    def sort_key(item):\n        abi, path = item\n        try:\n            abi_index = preferred_abis.index(abi)\n        except ValueError:\n            abi_index = len(preferred_abis)\n        return (abi_index, path)\n\n    best = min(candidates, key=sort_key)\n    sys.stdout.write(best[1])\n'
              resolved_path=$(python3 - "$variant_dir" -c "$python_script")
              resolved_path=$(printf '%s' "$resolved_path" | tr -d '\r\n')
              if [ -n "$resolved_path" ]; then
                printf '%s' "$resolved_path"
                return 0
              fi
            fi

            printf '%s' "$fallback"
          }

          apk_path="$(resolve_apk_path "app/build/outputs/apk/debug" "app/build/outputs/apk/debug/app-debug.apk")"
          printf 'Resolved debug APK path to %s\n' "$apk_path"

          if [ ! -f "$apk_path" ]; then
            echo "Debug APK not found at $apk_path; assembling it now"
            ./gradlew :app:assembleDebug --stacktrace
            apk_path="$(resolve_apk_path "app/build/outputs/apk/debug" "app/build/outputs/apk/debug/app-debug.apk")"
            printf 'Resolved debug APK path to %s after assemble\n' "$apk_path"
          fi

          if [ ! -f "$apk_path" ]; then
            echo "::error::Debug APK is still missing at $apk_path after assembly"
            exit 1
          fi

          echo "Waiting for emulator to report as online"
          adb wait-for-device

          boot_deadline=$((5 * 60))
          boot_elapsed=0
          until adb shell getprop sys.boot_completed 2>/dev/null | tr -d '\r' | grep -q '^1$'; do
            sleep 5
            boot_elapsed=$((boot_elapsed + 5))
            if [ $boot_elapsed -ge $boot_deadline ]; then
              echo "Emulator failed to report boot completion within $((boot_deadline / 60)) minutes" >&2
              exit 1
            fi
          done

          echo "Waiting for package manager command interface to become available"
          pm_deadline=$((5 * 60))
          pm_elapsed=0
          until adb shell cmd package list packages >/dev/null 2>&1; do
            sleep 5
            pm_elapsed=$((pm_elapsed + 5))
            if [ $pm_elapsed -ge $pm_deadline ]; then
              echo "Package manager service did not become available within $((pm_deadline / 60)) minutes" >&2
              exit 1
            fi
          done

          echo "Confirming package manager binder registration"
          pm_service_deadline=$((5 * 60))
          pm_service_elapsed=0
          while true; do
            if pm_status=$(adb shell service check package 2>/dev/null); then
              pm_status=$(printf '%s' "$pm_status" | tr -d '\r' | tr -d '\n')
              if printf '%s' "$pm_status" | grep -qE ': found$'; then
                break
              fi
            fi

            if [ $pm_service_elapsed -ge $pm_service_deadline ]; then
              echo "Package manager service binder did not become available within $((pm_service_deadline / 60)) minutes" >&2
              exit 1
            fi

            sleep 5
            pm_service_elapsed=$((pm_service_elapsed + 5))
          done

          echo "Installing $apk_path onto the emulator"
          install_attempt=1
          install_attempts_max=3
          while true; do
            if adb_install_with_fallback_screenshots "$apk_path"; then
              break
            fi

            if [ $install_attempt -ge $install_attempts_max ]; then
              echo "Failed to install $apk_path after $install_attempts_max attempts" >&2
              exit 1
            fi

            install_attempt=$((install_attempt + 1))
            echo "adb install failed (attempt $((install_attempt - 1))) — waiting for package manager before retrying"

            retry_deadline=$((2 * 60))
            retry_elapsed=0
            pm_service_deadline=$((2 * 60))
            pm_service_elapsed=0
            while true; do
              if pm_status=$(adb shell service check package 2>/dev/null); then
                pm_status=$(printf '%s' "$pm_status" | tr -d '\r' | tr -d '\n')
                if printf '%s' "$pm_status" | grep -qE ': found$'; then
                  break
                fi
              fi

              if [ $pm_service_elapsed -ge $pm_service_deadline ]; then
                echo "Package manager service binder did not recover within $((pm_service_deadline / 60)) minutes after failed install" >&2
                exit 1
              fi

              sleep 5
              pm_service_elapsed=$((pm_service_elapsed + 5))
            done
            until adb shell cmd package list packages >/dev/null 2>&1; do
              sleep 5
              retry_elapsed=$((retry_elapsed + 5))
              if [ $retry_elapsed -ge $retry_deadline ]; then
                echo "Package manager did not recover within $((retry_deadline / 60)) minutes after failed install" >&2
                exit 1
              fi
            done

            sleep 5
            echo "Retrying adb install (attempt $install_attempt of $install_attempts_max)"
          done
      - name: Install instrumentation harness for screenshots
        if: env.UNIT_TESTS_PASSED == 'true'
        run: |
          set -euo pipefail

          resolve_apk_path() {
            local variant_dir="$1"
            local fallback="$2"
            local metadata="${variant_dir}/output-metadata.json"

            if [ -f "$metadata" ]; then
              local resolved_path
              local python_script
              python_script=$'import json\nimport os\nimport sys\n\nvariant_dir = sys.argv[1]\nmetadata_path = os.path.join(variant_dir, "output-metadata.json")\n\npreferred_abis = ["", "x86_64", "arm64-v8a"]\ncandidates = []\n\ntry:\n    with open(metadata_path, "r", encoding="utf-8") as fh:\n        data = json.load(fh)\nexcept Exception:\n    data = None\n\nif data:\n    for element in data.get("elements", []):\n        output_file = element.get("outputFile")\n        if not output_file:\n            continue\n        path = os.path.join(variant_dir, output_file)\n        if not os.path.isfile(path):\n            continue\n        filters = element.get("filters") or []\n        abi = ""\n        for flt in filters:\n            if flt.get("filterType") == "ABI":\n                abi = (flt.get("value") or "").strip()\n                break\n        candidates.append((abi, path))\n\nif candidates:\n    def sort_key(item):\n        abi, path = item\n        try:\n            abi_index = preferred_abis.index(abi)\n        except ValueError:\n            abi_index = len(preferred_abis)\n        return (abi_index, path)\n\n    best = min(candidates, key=sort_key)\n    sys.stdout.write(best[1])\n'
              resolved_path=$(python3 - "$variant_dir" -c "$python_script")
              resolved_path=$(printf '%s' "$resolved_path" | tr -d '\r\n')
              if [ -n "$resolved_path" ]; then
                printf '%s' "$resolved_path"
                return 0
              fi
            fi

            printf '%s' "$fallback"
          }

          adb_install_with_fallback_android_test() {
            local apk_path="$1"

            if adb install -r -t "$apk_path"; then
              return 0
            fi

            local exit_code=$?
            echo "Streaming adb install failed with exit code $exit_code; retrying with --no-streaming" >&2

            if adb install --no-streaming -r -t "$apk_path"; then
              return 0
            fi

            local fallback_exit_code=$?
            return $fallback_exit_code
          }

          android_test_apk="$(resolve_apk_path "app/build/outputs/apk/androidTest/debug" "app/build/outputs/apk/androidTest/debug/app-debug-androidTest.apk")"
          printf 'Resolved androidTest APK path to %s\n' "$android_test_apk"

          if [ ! -f "$android_test_apk" ]; then
            echo "AndroidTest APK not found at $android_test_apk; assembling it now"
            ./gradlew :app:assembleDebugAndroidTest --stacktrace
            android_test_apk="$(resolve_apk_path "app/build/outputs/apk/androidTest/debug" "app/build/outputs/apk/androidTest/debug/app-debug-androidTest.apk")"
            printf 'Resolved androidTest APK path to %s after assemble\n' "$android_test_apk"
          fi

          if [ ! -f "$android_test_apk" ]; then
            echo "::error::AndroidTest APK is still missing at $android_test_apk after assembly"
            exit 1
          fi

          echo "Installing $android_test_apk onto the emulator"
          install_attempt=1
          install_attempts_max=3
          while true; do
            if adb_install_with_fallback_android_test "$android_test_apk"; then
              break
            fi

            if [ $install_attempt -ge $install_attempts_max ]; then
              echo "Failed to install $android_test_apk after $install_attempts_max attempts" >&2
              exit 1
            fi

            install_attempt=$((install_attempt + 1))
            echo "adb install failed (attempt $((install_attempt - 1))) — waiting for package manager before retrying"

            retry_deadline=$((2 * 60))
            retry_elapsed=0
            pm_service_deadline=$((2 * 60))
            pm_service_elapsed=0
            while true; do
              if pm_status=$(adb shell service check package 2>/dev/null); then
                pm_status=$(printf '%s' "$pm_status" | tr -d '\r' | tr -d '\n')
                if printf '%s' "$pm_status" | grep -qE ': found$'; then
                  break
                fi
              fi

              if [ $pm_service_elapsed -ge $pm_service_deadline ]; then
                echo "Package manager service binder did not recover within $((pm_service_deadline / 60)) minutes after failed install" >&2
                exit 1
              fi

              sleep 5
              pm_service_elapsed=$((pm_service_elapsed + 5))
            done
            until adb shell cmd package list packages >/dev/null 2>&1; do
              sleep 5
              retry_elapsed=$((retry_elapsed + 5))
              if [ $retry_elapsed -ge $retry_deadline ]; then
                echo "Package manager did not recover within $((retry_deadline / 60)) minutes after failed install" >&2
                exit 1
              fi
            done

            sleep 5
            echo "Retrying adb install (attempt $install_attempt of $install_attempts_max)"
          done
      - name: Capture screenshots
        if: env.UNIT_TESTS_PASSED == 'true'
        env:
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail

          resource_dir="${ARTIFACTS_DIR}/resources/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$resource_dir"

          resource_snapshot() {
            local label="$1"
            local path="$2"
            shift 2 || true
            python3 tools/device_resource_snapshot.py --label "$label" --output "$path" "$@"
          }

          base_dir="${ARTIFACTS_DIR}/screenshots/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$base_dir"

          READY_FLAG="cache/screenshot_ready.flag"
          DONE_FLAG="cache/screenshot_done.flag"
          HARNESS_CLASS="com.novapdf.reader.ScreenshotHarnessTest#openThousandPageDocumentForScreenshots"
          HARNESS_LOG="$base_dir/screenshot-harness.log"
          HARNESS_LOGCAT="$base_dir/screenshot-harness-logcat.log"
          PERFORMANCE_DIR="${ARTIFACTS_DIR}/performance/api${{ matrix.api }}/${{ matrix.device_label }}"
          METRICS_FILE_NAME="performance_metrics.csv"

          before_snapshot_path="${resource_dir}/screenshot-harness-before.json"
          after_snapshot_path="${resource_dir}/screenshot-harness-after.json"
          captured_after_snapshot=0

          resource_snapshot "screenshot-harness-before" "$before_snapshot_path" --include-properties

          compute_timeout_from_snapshot() {
            local snapshot_path="$1"
            local base_seconds="$2"
            python3 -c $'import json, sys\npath = sys.argv[1]\nbase = float(sys.argv[2])\nwith open(path, "r", encoding="utf-8") as handle:\n    data = json.load(handle)\n\ntotal_kb = float(data.get("mem_total_kb") or 0)\navailable_percent = float(data.get("mem_available_percent") or 0)\ncpu = float(data.get("cpu_usage_percent") or 0)\ncores = float(data.get("cpu_cores") or 0)\n\nscale = 1.0\nif total_kb > 0:\n    mem_gb = total_kb / (1024.0 * 1024.0)\n    if mem_gb < 2.0:\n        scale *= 2.8\n    elif mem_gb < 4.0:\n        scale *= 1.9\n    elif mem_gb < 6.0:\n        scale *= 1.4\n    elif mem_gb > 8.0:\n        scale *= 0.9\n    else:\n        scale *= 1.1\n\nif cores:\n    if cores <= 4:\n        scale *= 1.3\n    elif cores >= 8:\n        scale *= 0.9\n\nif available_percent and available_percent < 15.0:\n    scale *= 1.2\n\nif cpu and cpu > 85.0:\n    scale *= 1.15\n\ntimeout = base * scale\ntimeout = max(240.0, min(timeout, 1200.0))\nprint(int(round(timeout)))\n' "$snapshot_path" "$base_seconds"
          }

          ACTIVITY_MANAGER_TIMEOUT=$(compute_timeout_from_snapshot "$before_snapshot_path" 300)
          HARNESS_READY_TIMEOUT=$(compute_timeout_from_snapshot "$before_snapshot_path" 360)
          echo "Using dynamic timeouts for screenshot harness: activity manager ${ACTIVITY_MANAGER_TIMEOUT}s, readiness ${HARNESS_READY_TIMEOUT}s" >&2

          HARNESS_RUN_AS_PACKAGE="${PACKAGE_NAME}.test"
          APP_RUN_AS_PACKAGE="${PACKAGE_NAME}"

          cleanup_flags() {
            adb shell run-as "$HARNESS_RUN_AS_PACKAGE" sh -c "rm -f '$READY_FLAG' '$DONE_FLAG'" >/dev/null 2>&1 || true
          }

          cleanup_flags

          harness_pid=""
          rm -f "$HARNESS_LOGCAT"
          collect_harness_logcat() {
            rm -f "$HARNESS_LOGCAT"
            if adb logcat -d > "$HARNESS_LOGCAT"; then
              echo "Collected screenshot harness logcat at $HARNESS_LOGCAT" >&2
              if [ -s "$HARNESS_LOGCAT" ]; then
                echo "---- screenshot harness logcat (tail) ----" >&2
                tail -n 200 "$HARNESS_LOGCAT" >&2 || true
                echo "-----------------------------------------" >&2
              fi
            else
              echo "Failed to capture screenshot harness logcat" >&2
            fi
            adb logcat -c >/dev/null 2>&1 || true
          }
          collect_native_crash_artifacts() {
            local native_dir="${base_dir}/native-crash"

            if ! tools/collect_native_crash_artifacts.sh "$native_dir"; then
              echo "Failed to collect native crash artifacts" >&2
            fi
          }

          collect_app_crash_logs() {
            local crash_dir="crashlogs"
            local output_dir="${base_dir}/crashlogs"
            mkdir -p "$output_dir"

            local listing
            if ! listing=$(adb shell run-as "$APP_RUN_AS_PACKAGE" ls -1 "$crash_dir" 2>/dev/null | tr -d '\r'); then
              echo "Crash log directory unavailable for $APP_RUN_AS_PACKAGE" >&2
              return
            fi

            listing=$(printf '%s\n' "$listing" | awk 'NF')
            if [ -z "$listing" ]; then
              echo "No crash logs captured for $APP_RUN_AS_PACKAGE" >&2
              return
            fi

            echo "Collecting crash logs from $APP_RUN_AS_PACKAGE/$crash_dir" >&2
            while IFS= read -r entry; do
              local remote_path="$crash_dir/$entry"
              local local_path="$output_dir/$entry"
              if adb shell run-as "$APP_RUN_AS_PACKAGE" cat "$remote_path" > "$local_path"; then
                echo "Saved crash log to $local_path" >&2
                tail -n 40 "$local_path" >&2 || true
              else
                echo "Failed to export crash log $remote_path" >&2
              fi
            done <<< "$listing"

            collect_native_crash_artifacts
          }
          collect_performance_metrics() {
            local package="$1"
            local label="$2"

            if [ -z "$package" ]; then
              return
            fi

            if ! adb shell run-as "$package" sh -c "exit 0" >/dev/null 2>&1; then
              echo "run-as unavailable for $package; skipping performance metrics collection" >&2
              return
            fi

            local remote_files
            if ! remote_files=$(adb shell run-as "$package" sh -c "find . -maxdepth 5 -type f -name '$METRICS_FILE_NAME' 2>/dev/null" | tr -d '\r'); then
              echo "Failed to query performance metrics paths for $package" >&2
              return
            fi

            remote_files=$(printf '%s\n' "$remote_files" | awk 'NF')
            if [ -z "$remote_files" ]; then
              echo "No performance metrics located for $package" >&2
              return
            fi

            mkdir -p "$PERFORMANCE_DIR"
            while IFS= read -r remote_path; do
              remote_path=${remote_path#./}
              if [ -z "$remote_path" ]; then
                continue
              fi
              local sanitized="${remote_path//\//_}"
              local dest="$PERFORMANCE_DIR/${label}-${sanitized}"
              if adb shell run-as "$package" sh -c "cat '$remote_path'" > "$dest"; then
                echo "Exported performance metrics from $package:$remote_path to $dest" >&2
              else
                echo "Failed to export performance metrics from $package:$remote_path" >&2
                rm -f "$dest"
              fi
            done <<< "$remote_files"
          }
          resolve_harness_run_as_package() {
            local timeout=$((2 * 60))
            local elapsed=0
            local resolved=""
            local previous="$HARNESS_RUN_AS_PACKAGE"

            while [ $elapsed -lt $timeout ]; do
                if [ -f "$HARNESS_LOG" ]; then
                  resolved=$(python3 -c $'import sys\n\nif len(sys.argv) < 2:\n    sys.exit(0)\n\npath = sys.argv[1]\ntarget = "ScreenshotHarness: Resolved screenshot harness package name:"\npackage = ""\n\ntry:\n    with open(path, "r", encoding="utf-8", errors="replace") as handle:\n        for line in handle:\n            if target in line:\n                candidate = line.split(target, 1)[1].strip()\n                if candidate:\n                    package = candidate.split()[0]\nexcept Exception:\n    package = ""\n\nif package:\n    sys.stdout.write(package)\n' "$HARNESS_LOG")
                resolved=$(printf '%s' "$resolved" | tr -d '\r\n')
                if [ -n "$resolved" ]; then
                  if [ "$resolved" != "$HARNESS_RUN_AS_PACKAGE" ]; then
                    HARNESS_RUN_AS_PACKAGE="$resolved"
                    echo "Updated screenshot harness run-as package to $HARNESS_RUN_AS_PACKAGE" >&2
                    if [ "$previous" != "$HARNESS_RUN_AS_PACKAGE" ]; then
                      cleanup_flags
                    fi
                  fi
                  return 0
                fi
              fi

              if ! kill -0 "$harness_pid" >/dev/null 2>&1; then
                break
              fi

              sleep 1
              elapsed=$((elapsed + 1))
            done

            echo "Unable to determine screenshot harness package from instrumentation output; continuing with $HARNESS_RUN_AS_PACKAGE" >&2
            return 1
          }
          finish_harness() {
            if [ -n "${harness_pid:-}" ] && kill -0 "$harness_pid" >/dev/null 2>&1; then
              echo "Stopping screenshot harness instrumentation" >&2
              kill "$harness_pid" >/dev/null 2>&1 || true
              wait "$harness_pid" >/dev/null 2>&1 || true
            fi
            if [ "${captured_after_snapshot}" -eq 0 ]; then
              captured_after_snapshot=1
              resource_snapshot "screenshot-harness-after" "$after_snapshot_path"
            fi
            collect_performance_metrics "$HARNESS_RUN_AS_PACKAGE" "harness"
            collect_performance_metrics "$APP_RUN_AS_PACKAGE" "app"
            cleanup_flags
          }
          trap finish_harness EXIT

          wait_for_activity_manager() {
            local elapsed=0
            local timeout=${ACTIVITY_MANAGER_TIMEOUT:-300}
            while true; do
              if adb wait-for-device >/dev/null 2>&1; then
                local status
                status=$(adb shell service check activity 2>/dev/null | tr -d '\r' | tr -d '\n')
                if printf '%s\n' "$status" | grep -qE ': found$'; then
                  return 0
                fi
              fi

              if [ $elapsed -ge $timeout ]; then
                echo "::error::Timed out waiting for Activity Manager service before launching screenshot harness (timeout ${timeout}s)" >&2
                collect_harness_logcat
                collect_app_crash_logs
                exit 1
              fi

              sleep 5
              elapsed=$((elapsed + 5))
            done
          }

          wait_for_activity_manager

          echo "Launching screenshot harness instrumentation to load thousand-page PDF"
          adb logcat -c >/dev/null 2>&1 || true
          adb shell am instrument -w -r \
            -e runScreenshotHarness true \
            -e class "$HARNESS_CLASS" \
            ${PACKAGE_NAME}.test/dagger.hilt.android.testing.HiltTestRunner \
            >"$HARNESS_LOG" 2>&1 &
          harness_pid=$!

          resolve_harness_run_as_package || true

          wait_for_harness() {
            local elapsed=0
            local timeout=${HARNESS_READY_TIMEOUT:-360}
            while true; do
              if ! kill -0 "$harness_pid" >/dev/null 2>&1; then
                echo "::error::Screenshot harness instrumentation exited before reporting readiness" >&2
                cat "$HARNESS_LOG" >&2 || true
                wait "$harness_pid" || true
                collect_harness_logcat
                collect_app_crash_logs
                exit 1
              fi

              if adb shell run-as "$HARNESS_RUN_AS_PACKAGE" sh -c "[ -f '$READY_FLAG' ]" >/dev/null 2>&1; then
                break
              fi

              if [ $elapsed -ge $timeout ]; then
                echo "::error::Timed out waiting for screenshot harness readiness flag (timeout ${timeout}s)" >&2
                cat "$HARNESS_LOG" >&2 || true
                collect_harness_logcat
                collect_app_crash_logs
                exit 1
              fi

              sleep 2
              elapsed=$((elapsed + 2))
            done
          }

          wait_for_harness

          adb shell settings put system accelerometer_rotation 0 || true
          adb shell settings put system user_rotation 0 || true
          adb shell cmd uimode night no || true
          adb shell settings put secure high_text_contrast_enabled 0 || true
          adb shell settings put secure accessibility_display_daltonizer_enabled 0 || true
          sleep 5

          capture_set() {
            local label="$1"
            local orientation="$2"
            local night_mode="$3"
            local high_contrast="$4"
            local daltonizer="$5"
            local count="$6"

            local target_dir="${base_dir}/${label}"
            mkdir -p "$target_dir"

            if [ "$orientation" = "portrait" ]; then
              adb shell settings put system user_rotation 0 || true
            else
              adb shell settings put system user_rotation 1 || true
            fi

            adb shell cmd uimode night "$night_mode" || true
            adb shell settings put secure high_text_contrast_enabled "$high_contrast" || true

            if [ "$daltonizer" = "none" ]; then
              adb shell settings put secure accessibility_display_daltonizer_enabled 0 || true
            else
              adb shell settings put secure accessibility_display_daltonizer_enabled 1 || true
              adb shell settings put secure accessibility_display_daltonizer "$daltonizer" || true
            fi

            # Allow the UI to settle after changing orientation/theme/accessibility flags
            sleep 4

            for i in $(seq -w 1 "$count"); do
              adb exec-out screencap -p > "$target_dir/screenshot_${i}.png"
              sleep 1
            done
          }

          capture_set "light-portrait-standard" portrait no 0 none 5
          capture_set "light-portrait-accessibility" portrait no 1 0 4
          capture_set "dark-portrait-standard" portrait yes 0 none 4
          capture_set "dark-landscape-accessibility" landscape yes 1 1 4
          capture_set "light-landscape-standard" landscape no 0 none 3

          if ! adb shell run-as "$HARNESS_RUN_AS_PACKAGE" sh -c "printf '' > '$DONE_FLAG'" >/dev/null 2>&1; then
            echo "::error::Failed to signal screenshot harness completion" >&2
            exit 1
          fi

          if ! wait "$harness_pid"; then
            status=$?
            echo "::error::Screenshot harness instrumentation reported failure" >&2
            cat "$HARNESS_LOG" >&2 || true
            collect_harness_logcat
            collect_app_crash_logs
            exit $status
          fi

          trap - EXIT
          finish_harness

          adb shell settings put system user_rotation 0 || true
          adb shell cmd uimode night no || true
          adb shell settings put secure high_text_contrast_enabled 0 || true
          adb shell settings put secure accessibility_display_daltonizer_enabled 0 || true
      - name: Collect and validate device logs after screenshot harness
        if: env.UNIT_TESTS_PASSED == 'true'
        env:
          PACKAGE_NAME: ${{ env.APP_PACKAGE_NAME }}
        run: |
          set -euo pipefail
          logs_dir="device-logs/screenshot-harness"
          mkdir -p "$logs_dir"
          logcat_path="${logs_dir}/logcat.txt"
          bugreport_path="${logs_dir}/bugreport.zip"
          adb logcat -d > "$logcat_path"
          bugreport_args=()
          if timeout 5m adb bugreport "$bugreport_path"; then
            bugreport_args+=("$bugreport_path")
          else
            echo "::warning::Failed to capture bugreport after screenshot harness; continuing with logcat only" >&2
          fi
          native_dir="${logs_dir}/native-crash"
          if ! tools/collect_native_crash_artifacts.sh "$native_dir"; then
            echo "::warning::Failed to collect native crash artifacts snapshot" >&2
          fi
          if python3 tools/check_logcat_for_crashes.py "$logcat_path" "${bugreport_args[@]}" --package "$PACKAGE_NAME"; then
            echo "Device logs cleared crash and ANR checks" >&2
          else
            echo "::error::Crash signatures detected in device logs; collecting native diagnostics" >&2
            exit 1
          fi
      - name: Verify instrumentation log tails
        if: env.UNIT_TESTS_PASSED == 'true'
        run: |
          set -euo pipefail
          python3 tools/scripts/verify_log_markers.py \
            --path "device-logs/connected-android-test/logcat.txt" \
            --path "device-logs/screenshot-harness/logcat.txt" \
            --require-any "TestRunner: run finished||INSTRUMENTATION_RESULT: stream=||INSTRUMENTATION_STATUS_CODE: -1"
      - name: Collect emulator logs
        if: always()
        run: |
          set -euo pipefail
          log_dir="${ARTIFACTS_DIR}/logs/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$log_dir"

          adb -s emulator-5554 logcat -d > "$log_dir/emulator.log" || true

          if adb -s emulator-5554 get-state >/dev/null 2>&1; then
            adb -s emulator-5554 shell dumpsys activity processes > "$log_dir/dumpsys-activity.txt" || true

            timeout_cmd=(timeout 5m)
            if ! command -v timeout >/dev/null 2>&1; then
              timeout_cmd=()
            fi

            if "${timeout_cmd[@]}" adb -s emulator-5554 bugreport "$log_dir/emulator-bugreport.zip"; then
              echo "Captured emulator bugreport at $log_dir/emulator-bugreport.zip" >&2
            else
              echo "::warning::Failed to capture emulator bugreport" >&2
              rm -f "$log_dir/emulator-bugreport.zip"
            fi
          fi
      - name: Stage device diagnostics
        if: always()
        run: |
          set -euo pipefail
          target_dir="${ARTIFACTS_DIR}/logs/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$target_dir"
          if [ -d device-logs ]; then
            if command -v rsync >/dev/null 2>&1; then
              rsync -a device-logs/ "$target_dir/"
            else
              cp -R device-logs/. "$target_dir/"
            fi
          fi
      - name: Capture failure screenshot
        if: failure()
        run: |
          set -euo pipefail
          target_dir="${ARTIFACTS_DIR}/screenshots/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$target_dir"
          if adb -s emulator-5554 get-state >/dev/null 2>&1; then
            timestamp=$(date -u +%Y%m%dT%H%M%SZ)
            screenshot_path="${target_dir}/failure-${timestamp}.png"
            if adb -s emulator-5554 exec-out screencap -p > "$screenshot_path"; then
              echo "Captured failure screenshot at $screenshot_path" >&2
            else
              echo "::warning::Failed to capture emulator screenshot on failure" >&2
              rm -f "$screenshot_path"
            fi
          else
            echo "::warning::Emulator not reachable for failure screenshot" >&2
          fi
      - name: Capture emulator memory before teardown
        if: always()
        run: |
          set -euo pipefail
          serial="${EMULATOR_SERIAL:-emulator-5554}"
          resource_dir="${ARTIFACTS_DIR}/resources/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$resource_dir"
          if adb -s "$serial" get-state >/dev/null 2>&1; then
            python3 tools/device_resource_snapshot.py \
              --label "pre-teardown" \
              --serial "$serial" \
              --allow-exhausted \
              --output "${resource_dir}/pre-teardown.json"
          else
            echo "::warning::Emulator ${serial} unreachable; skipping pre-teardown memory snapshot" >&2
          fi
          if command -v free >/dev/null 2>&1; then
            echo "Host memory snapshot before teardown ($(date -u '+%Y-%m-%dT%H:%M:%SZ'))"
            free -h || true
          elif command -v vm_stat >/dev/null 2>&1; then
            echo "Host memory snapshot before teardown ($(date -u '+%Y-%m-%dT%H:%M:%SZ'))"
            vm_stat || true
          fi
      - name: Stop emulator
        if: always()
        run: adb -s emulator-5554 emu kill || true
      - name: Stop emulator watchdog
        if: always()
        run: |
          set -euo pipefail

          status=0

          if [ -n "${EMULATOR_WATCHDOG_PID:-}" ]; then
            if ! wait "$EMULATOR_WATCHDOG_PID"; then
              status=$?
            fi
          fi

          if [ -n "${EMULATOR_WATCHDOG_LOG:-}" ] && [ -f "$EMULATOR_WATCHDOG_LOG" ]; then
            echo "===== emulator watchdog log ====="
            cat "$EMULATOR_WATCHDOG_LOG"
            echo "================================="
          fi

          if [ "$status" -ne 0 ]; then
            echo "::error::Emulator watchdog exited with status $status" >&2
            exit "$status"
          fi
      - name: Bundle release app
        if: env.UNIT_TESTS_PASSED == 'true'
        run: ./gradlew bundleRelease --stacktrace
      - name: Collect signed release bundle
        if: env.UNIT_TESTS_PASSED == 'true'
        run: |
          set -euo pipefail
          bundle_path="app/build/outputs/bundle/release/app-release.aab"
          if [ ! -f "$bundle_path" ]; then
            echo "Bundle not found at $bundle_path" >&2
            exit 1
          fi
          target_dir="${ARTIFACTS_DIR}/bundles/api${{ matrix.api }}/${{ matrix.device_label }}"
          mkdir -p "$target_dir"
          signed_bundle="$target_dir/NovaPDFReader-release-signed-api${{ matrix.api }}-${{ matrix.device_label }}.aab"
          cp "$bundle_path" "$signed_bundle"
          jarsigner -verify -verbose -certs "$signed_bundle"
      - name: Stage test and lint reports
        if: always()
        run: |
          mkdir -p "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}"
          if [ -d app/build/reports ]; then
            if command -v rsync >/dev/null 2>&1; then
              rsync -a app/build/reports/ "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}/"
            else
              cp -R app/build/reports/. "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}/"
            fi
          fi
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: nova-build-${{ matrix.api }}-${{ matrix.device_label }}
          path: ${{ env.ARTIFACTS_DIR }}
          if-no-files-found: warn
      - name: Upload build outputs to S3
        if: success()
        env:
          BUCKET: ${{ secrets.S3_BUCKET_NAME }}
          S3_PREFIX: ci/${{ github.run_id }}/api${{ matrix.api }}/${{ matrix.device_label }}
        run: |
          set -euo pipefail
          if [ -d "${ARTIFACTS_DIR}/bundles/api${{ matrix.api }}/${{ matrix.device_label }}" ]; then
            aws s3 cp "${ARTIFACTS_DIR}/bundles/api${{ matrix.api }}/${{ matrix.device_label }}/" "s3://${BUCKET}/${S3_PREFIX}/bundle/" --recursive
          fi
          if [ -d "${ARTIFACTS_DIR}/screenshots/api${{ matrix.api }}/${{ matrix.device_label }}" ]; then
            aws s3 cp "${ARTIFACTS_DIR}/screenshots/api${{ matrix.api }}/${{ matrix.device_label }}/" "s3://${BUCKET}/${S3_PREFIX}/screenshots/" --recursive
          fi
          if [ -d "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}" ]; then
            aws s3 cp "${ARTIFACTS_DIR}/reports/api${{ matrix.api }}/${{ matrix.device_label }}/" "s3://${BUCKET}/${S3_PREFIX}/reports/" --recursive
          fi
          if [ -d "${ARTIFACTS_DIR}/logs/api${{ matrix.api }}/${{ matrix.device_label }}" ]; then
            aws s3 cp "${ARTIFACTS_DIR}/logs/api${{ matrix.api }}/${{ matrix.device_label }}/" "s3://${BUCKET}/${S3_PREFIX}/logs/" --recursive
          fi

  firebase-instrumentation:
    name: Firebase instrumentation (physical devices)
    runs-on: ubuntu-latest
    timeout-minutes: 120
    needs:
      - build-test
      - heavy-pdf-tests
    if: needs.build-test.result == 'success' && needs.heavy-pdf-tests.result == 'success' && needs.build-test.outputs.firebase_configured == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - device_label: pixel6-physical
            model: oriole
            version: 33
          - device_label: pixel7pro-physical
            model: cheetah
            version: 33
    env:
      FIREBASE_PROJECT_ID: ${{ vars.FIREBASE_PROJECT_ID || secrets.FIREBASE_PROJECT_ID }}
    steps:
      - name: Configure Firebase results path
        run: echo "RESULTS_JSON=$RUNNER_TEMP/firebase-results.json" >> "$GITHUB_ENV"
      - name: Validate Firebase configuration
        run: |
          set -e
          if [ -z "${FIREBASE_PROJECT_ID:-}" ]; then
            echo "::error::Firebase project ID not provided; ensure FIREBASE_PROJECT_ID is configured as a repository variable or secret."
            exit 1
          fi
          if [ -z "${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}" ]; then
            echo "::error::Firebase service account secret FIREBASE_SERVICE_ACCOUNT_JSON is missing."
            exit 1
          fi
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}
      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.FIREBASE_PROJECT_ID }}
      - name: Assemble instrumentation artifacts
        run: ./gradlew :app:assembleDebug :app:assembleDebugAndroidTest --stacktrace --no-build-cache
      - name: Run Firebase Test Lab instrumentation
        id: firebase
        env:
          DEVICE_MODEL: ${{ matrix.model }}
          DEVICE_VERSION: ${{ matrix.version }}
          DEVICE_LABEL: ${{ matrix.device_label }}
        run: |
          set -euo pipefail
          results_path="$RESULTS_JSON"
          rm -f "$results_path"

          resolve_apk_path() {
            local variant_dir="$1"
            local fallback="$2"
            local metadata="${variant_dir}/output-metadata.json"

            if [ -f "$metadata" ]; then
              local resolved_path
              local python_script
              python_script=$'import json\nimport os\nimport sys\n\nvariant_dir = sys.argv[1]\nmetadata_path = os.path.join(variant_dir, "output-metadata.json")\n\npreferred_abis = ["", "x86_64", "arm64-v8a"]\ncandidates = []\n\ntry:\n    with open(metadata_path, "r", encoding="utf-8") as fh:\n        data = json.load(fh)\nexcept Exception:\n    data = None\n\nif data:\n    for element in data.get("elements", []):\n        output_file = element.get("outputFile")\n        if not output_file:\n            continue\n        path = os.path.join(variant_dir, output_file)\n        if not os.path.isfile(path):\n            continue\n        filters = element.get("filters") or []\n        abi = ""\n        for flt in filters:\n            if flt.get("filterType") == "ABI":\n                abi = (flt.get("value") or "").strip()\n                break\n        candidates.append((abi, path))\n\nif candidates:\n    def sort_key(item):\n        abi, path = item\n        try:\n            abi_index = preferred_abis.index(abi)\n        except ValueError:\n            abi_index = len(preferred_abis)\n        return (abi_index, path)\n\n    best = min(candidates, key=sort_key)\n    sys.stdout.write(best[1])\n'
              resolved_path=$(python3 - "$variant_dir" -c "$python_script")
              resolved_path=$(printf '%s' "$resolved_path" | tr -d '\r\n')
              if [ -n "$resolved_path" ]; then
                printf '%s' "$resolved_path"
                return 0
              fi
            fi

            printf '%s' "$fallback"
          }

          app_apk="$(resolve_apk_path "app/build/outputs/apk/debug" "app/build/outputs/apk/debug/app-debug.apk")"
          android_test_apk="$(resolve_apk_path "app/build/outputs/apk/androidTest/debug" "app/build/outputs/apk/androidTest/debug/app-debug-androidTest.apk")"

          printf 'Resolved Firebase debug APK path to %s\n' "$app_apk"
          printf 'Resolved Firebase androidTest APK path to %s\n' "$android_test_apk"

          if [ ! -f "$app_apk" ]; then
            echo "::error::Resolved debug APK missing at $app_apk" >&2
            exit 1
          fi

          if [ ! -f "$android_test_apk" ]; then
            echo "::error::Resolved androidTest APK missing at $android_test_apk" >&2
            exit 1
          fi

          set +e
          gcloud firebase test android run \
            --type instrumentation \
            --app "$app_apk" \
            --test "$android_test_apk" \
            --device model="$DEVICE_MODEL",version="$DEVICE_VERSION",locale=en,orientation=portrait \
            --timeout 30m \
            --num-flaky-test-attempts=1 \
            --results-history-name="ci-physical-devices" \
            --format=json > "$results_path"
          status=$?
          set -e

          if [ $status -ne 0 ]; then
            echo "::error::gcloud firebase test command failed with exit code $status"
            cat "$results_path" || true
            exit $status
          fi

          python3 - <<'PY'
            import json
            import os
            import sys

            results_path = os.environ["RESULTS_JSON"]
            with open(results_path, "r", encoding="utf-8") as fh:
                payload = json.load(fh)

            outcome = payload.get("outcomeSummary")
            storage_path = payload.get("resultStoragePath")
            matrix_id = payload.get("testMatrixId")

            print(f"Firebase Test Lab matrix {matrix_id} completed with outcome {outcome}")

            if storage_path:
                with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
                    output.write(f"storage_path={storage_path}\n")
                    output.write(f"matrix_id={matrix_id}\n")

            if outcome != "SUCCESS":
                print(f"::error::Firebase instrumentation failed with outcome {outcome}")
                sys.exit(1)
          PY
      - name: Download Firebase results
        if: always()
        env:
          STORAGE_PATH: ${{ steps.firebase.outputs.storage_path }}
          DEVICE_LABEL: ${{ matrix.device_label }}
        run: |
          set -euo pipefail
          if [ -z "${STORAGE_PATH:-}" ]; then
            echo "No Firebase results storage path found; skipping download."
            exit 0
          fi

          target_dir="firebase-results/${DEVICE_LABEL}"
          mkdir -p "$target_dir"
          gcloud storage cp --recursive "${STORAGE_PATH}/*" "$target_dir/"
      - name: Upload Firebase artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: firebase-${{ matrix.device_label }}
          path: firebase-results
          if-no-files-found: warn
      - name: Verify Caffeine is absent from build outputs
        if: always()
        run: python3 tools/scripts/verify_no_caffeine.py --github
